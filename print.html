<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>xv6ノート</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="top.html">XV6ノート</a></li><li class="chapter-item expanded affix "><a href="00_env.html">環境</a></li><li class="chapter-item expanded "><a href="chapter_01/01_build.html"><strong aria-hidden="true">1.</strong> ビルドと実行</a></li><li class="chapter-item expanded "><a href="chapter_02/02_00_xv6_img_build.html"><strong aria-hidden="true">2.</strong> xv6.imgのビルド</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_02/02_01_xv6_img.html"><strong aria-hidden="true">2.1.</strong> ターゲットxv6.img</a></li><li class="chapter-item expanded "><a href="chapter_02/02_02_makefile_val.html"><strong aria-hidden="true">2.2.</strong> Makefile内の変数</a></li><li class="chapter-item expanded "><a href="chapter_02/02_03_bootblock.html"><strong aria-hidden="true">2.3.</strong> ターゲットbootblock</a></li><li class="chapter-item expanded "><a href="chapter_02/02_04_kernel.html"><strong aria-hidden="true">2.4.</strong> ターゲットkernel</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_03/03_00_load_kernel.html"><strong aria-hidden="true">3.</strong> カーネルのロード</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_03/03_01_bootasm.html"><strong aria-hidden="true">3.1.</strong> bootasm.S</a></li><li class="chapter-item expanded "><a href="chapter_03/03_02_bootmain.html"><strong aria-hidden="true">3.2.</strong> bootmain関数</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_04/04_00_paging.html"><strong aria-hidden="true">4.</strong> ページング機構の有効化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_04/04_01_entry.html"><strong aria-hidden="true">4.1.</strong> entry.S</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_05/05_00_exec_kernel.html"><strong aria-hidden="true">5.</strong> カーネルの実行</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_05/05_01_main.html"><strong aria-hidden="true">5.1.</strong> main関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_02_kinit1.html"><strong aria-hidden="true">5.2.</strong> kinit1関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_03_kvmalloc.html"><strong aria-hidden="true">5.3.</strong> kvmalloc関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_04_mpinit.html"><strong aria-hidden="true">5.4.</strong> mpinit関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_05_lapicinit.html"><strong aria-hidden="true">5.5.</strong> lapicinit関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_06_seginit.html"><strong aria-hidden="true">5.6.</strong> seginit関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_07_picinit.html"><strong aria-hidden="true">5.7.</strong> picinit関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_08_ioapicinit.html"><strong aria-hidden="true">5.8.</strong> ioapicinit関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_09_consoleinit.html"><strong aria-hidden="true">5.9.</strong> consoleinit関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_10_lock.html"><strong aria-hidden="true">5.10.</strong> ロック（spinlock, sleeplock）</a></li><li class="chapter-item expanded "><a href="chapter_05/05_11_inode.html"><strong aria-hidden="true">5.11.</strong> iノード</a></li><li class="chapter-item expanded "><a href="chapter_05/05_12_bcache.html"><strong aria-hidden="true">5.12.</strong> バッファキャッシュとディスクの読み書き</a></li><li class="chapter-item expanded "><a href="chapter_05/05_13_uartinit.html"><strong aria-hidden="true">5.13.</strong> uartinit関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_14_pinit.html"><strong aria-hidden="true">5.14.</strong> pinit関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_15_tvinit.html"><strong aria-hidden="true">5.15.</strong> tvinit関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_16_binit.html"><strong aria-hidden="true">5.16.</strong> binit関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_17_fileinit.html"><strong aria-hidden="true">5.17.</strong> fileinit関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_18_ideinit.html"><strong aria-hidden="true">5.18.</strong> ideinit関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_19_startothers.html"><strong aria-hidden="true">5.19.</strong> startothers関数とmpmain関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_20_kinit2.html"><strong aria-hidden="true">5.20.</strong> kinit2関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_21_userinit.html"><strong aria-hidden="true">5.21.</strong> userinit関数</a></li><li class="chapter-item expanded "><a href="chapter_05/05_22_scheduler.html"><strong aria-hidden="true">5.22.</strong> スケジューラとコンテキストスイッチ</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_06/06_00_fs_img.html"><strong aria-hidden="true">6.</strong> fs.imgの作成</a></li><li class="chapter-item expanded "><a href="chapter_07/07_00_init.html"><strong aria-hidden="true">7.</strong> initの実行</a></li><li class="chapter-item expanded "><a href="chapter_08/08_00_sh.html"><strong aria-hidden="true">8.</strong> shの実行</a></li><li class="chapter-item expanded "><a href="ref_links.html"><strong aria-hidden="true">9.</strong> 参考リンク</a></li><li class="chapter-item expanded "><a href="ref_books.html"><strong aria-hidden="true">10.</strong> 参考書籍</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">xv6ノート</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#xv6ノート" id="xv6ノート">xv6ノート</a></h1>
<p>これはxv6を読んだ際のノート。</p>
<p>参考資料は<a href="ref_links.html">「9. 参考リンク」</a>と<a href="ref_books.html">「10. 参考書籍」</a>に列挙した。<br />
また、ノートの節々でどの参考資料を参照したのかを記した。</p>
<h1><a class="header" href="#環境" id="環境">環境</a></h1>
<p>使用したソースコードやツールのバージョン。</p>
<ul>
<li>xv6 commit <a href="https://github.com/mit-pdos/xv6-public/commit/eeb7b415dbcb12cc362d0783e41c3d1f44066b17">eeb7b415dbcb12cc362d0783e41c3d1f44066b17</a></li>
<li>Linux 4.19.128-microsoft-standard #1 SMP Tue Jun 23 12:58:10 UTC 2020 x86_64 GNU/Linux</li>
<li>Debian 9.11</li>
<li>gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1)</li>
<li>GNU ld (GNU Binutils for Debian) 2.28</li>
<li>GNU Make 4.1</li>
<li>GNU objcopy (GNU Binutils for Debian) 2.28</li>
<li>GNU objdump (GNU Binutils for Debian) 2.28</li>
<li>GNU readelf (GNU Binutils for Debian) 2.28</li>
<li>QEMU emulator version 2.8.1(Debian 1:2.8+dfsg-6+deb9u8)</li>
<li>GNU gdb (Debian 7.12-6) 7.12.0.20161007-git</li>
</ul>
<h1><a class="header" href="#1-ビルドと実行" id="1-ビルドと実行">1. ビルドと実行</a></h1>
<p>ビルドと実行は、<code>make</code>と<code>make qemu</code>で行えるとREADMEに記載がある。
また以下の記事から<code>make qemu-nox</code>でXなしで実行でき、<code>make qemu-nox-gdb</code>でXなしでgdbでデバッグできることが分かる。
<a href="https://qiita.com/ksky/items/974ad1249cfb2dcf5437">「xv6のデバッグ環境をつくる」（リンク2）</a></p>
<p>コンパイル時にレベル2の最適化オプションが付与されているので、デバッグの際に変数の中身が見れないことがある。
そのときは、MakefileのCFLAGSからオプションO2を削ると変数の中身が見える。</p>
<p>Makefile</p>
<pre><code class="language-Makefile">#CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -Wall -MD -ggdb -m32 -fno-omit-frame-pointer
</code></pre>
<p>シングルスレッドでの動作を確認したいときは、MakefileのCPUS変数の値を1にする。</p>
<p>Makefile</p>
<pre><code class="language-Makefile">#CPUS := 2
CPUS := 1
</code></pre>
<p>また、wsl上でqemuやgdbを動かしていて、キーボード入力などのためにXを使いたいとき（qemu-noxで実行するとシリアルポートを使うことになる）は、windows側でXサーバを起動し、wsl側の環境変数DISPLAYを<code>&lt;win側のvethのアドレス&gt;:0</code>として、<code>make qemu-gdb</code>を実行する。
XサーバにVcXsrvを使う場合は以下の記事が参考になる。
<a href="https://astherier.com/blog/2020/08/run-gui-apps-on-wsl2/#toc_id_2">「AsTechLog WSL2＋Ubuntu 20.04でGUIアプリを動かす」（リンク26）</a></p>
<h1><a class="header" href="#2-xv6imgのビルド" id="2-xv6imgのビルド">2. xv6.imgのビルド</a></h1>
<p><code>make</code>の実行</p>
<h1><a class="header" href="#21-ターゲットxv6img" id="21-ターゲットxv6img">2.1. ターゲットxv6.img</a></h1>
<p>Makefileの最初のターゲットがxv6.imgなので、<code>make</code>を実行するとxv6.imgが作られる。
xv6.imgはbootblockとkernelから次のように作られる。</p>
<ol>
<li>ddコマンドで0埋めされた512*10000=5.12MBのxv6.imgファイルを作る</li>
<li>ddコマンドでxv6.imgファイルの頭（0セクタ目）にbootblockを差し込む</li>
<li>ddコマンドでxv6.imgファイルの先頭から512バイトの位置（1セクタ目）にkernelを差し込む</li>
</ol>
<p>Makefile</p>
<pre><code class="language-Makefile">xv6.img: bootblock kernel
    dd if=/dev/zero of=xv6.img count=10000
    dd if=bootblock of=xv6.img conv=notrunc
    dd if=kernel of=xv6.img seek=1 conv=notrunc
</code></pre>
<h1><a class="header" href="#22-makefile内の変数" id="22-makefile内の変数">2.2. Makefile内の変数</a></h1>
<p>ターゲットbootblockとkernelを見る前に、Makefile内の変数を確認する。<br />
変数CCがgccなのでコンパイラにはgccを使う。<br />
変数CFLAGSは後ろの方が環境によって変わるようなので、makeを実行して中身を確認すると以下のようになっていることが分かる。<br />
<code>CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector</code><br />
各オプションの意味はマニュアル<a href="https://gcc.gnu.org/onlinedocs/gcc-6.5.0/gcc/">「Using the GNU Compiler Collection (GCC)」（リンク3）</a>を見るとだいたいわかる。
知りたいオプションをOption Summaryページでページ内検索して、各ページに飛ぶのと楽。</p>
<table><thead><tr><th>Option</th><th>意味</th></tr></thead><tbody>
<tr><td>fno-pic</td><td>マニュアルにこのオプションの記載はないが、fpicオプションはあるのでその否定だとわかる。出力を位置独立コード（Position Independent Code）にしない。位置独立コードに関しては<a href="chapter_02/ref_books.html">「リンカ・ローダ 実践開発テクニック」（書籍1）</a>に詳しく載っている。</td></tr>
<tr><td>static</td><td>動的ライブラリを静的リンクする。</td></tr>
<tr><td>fno-builtin</td><td>組み込み関数を使わないようにする。</td></tr>
<tr><td>O2</td><td>レベル2の最適化オプションを有効にする。</td></tr>
<tr><td>Wall</td><td>警告オプションを有効にする。</td></tr>
<tr><td>MD</td><td>拡張子「*.d」ファイルを作成し、依存関係にあるファイル名を書き込んでくれる。</td></tr>
<tr><td>ggdb</td><td>gdbで使用するデバッグ情報を作る。</td></tr>
<tr><td>m32</td><td>int, long, ポインタを32bitにする。</td></tr>
<tr><td>Werror</td><td>全ての警告をエラーにする。</td></tr>
<tr><td>fno-omit-frame-pointer</td><td>fomit-frame-pointerオプションの否定。関数呼び出しにて必ずベースポインタを使う。</td></tr>
<tr><td>fno-stack-protector</td><td>fstack-protectorオプションの否定。バッファオーバーフローやスタックスマッシング攻撃をチェックするコードを追加しない。</td></tr>
</tbody></table>
<p>変数LDがldなのでリンカはldを使うことが分かる。<br />
変数LDFLAGSもCFLAGS同様にmakeを実行して出力を確認すると以下のようになっていることが分かる。<br />
<code>LDFLAGS = -m    elf_i386</code><br />
オプションの意味はマニュアル<a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html">「Using ld The GNU linker ld version 2 January 1994」（リンク4）</a>で確認できる。このマニュアルはIndexからオプションが簡単に探せる。</p>
<table><thead><tr><th>Option</th><th>意味</th></tr></thead><tbody>
<tr><td>m</td><td>指定したリンカをエミュレートする。ここではelf_i386をエミュレート。elfについては<a href="chapter_02/ref_books.html">「リンカ・ローダ 実践開発テクニック」（書籍1）</a>に詳しく記載されている。</td></tr>
</tbody></table>
<p>変数OBJDUMPはobjdump。<br />
変数OBJCOPYはobjcopy。マニュアル<a href="https://sourceware.org/binutils/docs-2.35/binutils/objcopy.html#objcopy">「3 objcopy」（リンク5）</a>によると、Oオプションで出力ファイルのフォーマットを指定できる。また、出力フォーマットにバイナリを指定した場合、オブジェクトには以下の3つのシンボルが作成され、プログラムからデータにアクセスすることができる。</p>
<ul>
<li>_binary_&lt;ファイル名&gt;_start</li>
<li>_binary_&lt;ファイル名&gt;_end</li>
<li>_binary_&lt;ファイル名&gt;_size</li>
</ul>
<p>例えば画像ファイルをオブジェクトファイルに変換し、プログラム内で上記シンボルからアクセスすることができる。<br />
これらのシンボルはリンカldのbオプションでバイナリを指定した際にも作成される。</p>
<h1><a class="header" href="#23-ターゲットbootblock" id="23-ターゲットbootblock">2.3. ターゲットbootblock</a></h1>
<p>bootblockは次のように作られる。</p>
<ol>
<li>bootmain.cをコンパイルする。nostdincオプションはシステムからヘッダーファイルを探さないようにするオプションで、Iオプションで指定されたディレクトリからヘッダーファイルを探す。つまりここではカレントディレクトリから探す。</li>
<li>bootasm.Sをコンパイルする。</li>
<li>bootblock.oとしてbootasm.oとbootmain.oをリンクする。Nオプションはtextセクションとdataセクションを読み書き可能にする。また、dataに関するセグメントをページに揃えないようにする。eオプションはエントリポイントを指定する。ここではstartをエントリポイントとしている。Ttextオプションはtextセグメントの開始アドレスを設定する。ここでは0x7C00にしている。0x7C00はBIOSがMBRをロードするアドレス。</li>
<li>objdumpを使ってbootblock.oをディスアセンブリしてbootblock.asmを作成する。このファイルは使用しないが、アセンブリを見たいときに少し便利。</li>
<li>objcopyを使ってbootblock.oからbootblockを作る。Sオプションは再配置情報とシンボル情報を削除する。Oオプションで出力をbinaryとする。jオプションは出力するセクションを指定する。つまりtextセクションだけをコピーする。</li>
<li>sign.plを実行してbootblockをMBRにする。bootblockが510バイトより大きいときはエラーにする。そうでない場合は509バイト目までを0埋めして、510～511バイトにブートシグニチャ0x55AAを追加する。</li>
</ol>
<p>Makefile</p>
<pre><code class="language-Makefile">bootblock: bootasm.S bootmain.c
    $(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
    $(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
    $(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o                                                                   
    $(OBJDUMP) -S bootblock.o &gt; bootblock.asm
    $(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
    ./sign.pl bootblock
</code></pre>
<h1><a class="header" href="#24-ターゲットkernel" id="24-ターゲットkernel">2.4. ターゲットkernel</a></h1>
<p>kernelの依存先としてentryotherとinitcodeがあるが、それらについては後ほど読むことにする。<br />
kernelは次のように作られる。</p>
<ol>
<li>ターゲットkernelに依存している他のターゲットを作成する。
ひとつめが$(OBJS)になっていて、GNU makeの暗黙のルールにより、変数OJBSに記載されているオブジェクトが*.cや*.Sから作成される。
この時、vectors.oの作成のところでvectors.cもvectors.Sもないので、Makefile内のターゲットvectors.Sが実行され、vectors.plが実行される。
vectors.plはvector0からvector255までの割り込みハンドラが定義されたvectors.Sを作成する。
makeの暗黙のルールについてはマニュアル<a href="https://www.gnu.org/software/make/manual/make.html">「GNU make」（リンク6）</a>の「10 Using Implicit Rules」に記載されている。</li>
<li>各オブジェクトをリンクし、バイナリファイルとしてkernelを作る。
Tオプションはリンカスクリプトを指定する。ここではkernel.ldを使う。kernel.ldを読むと、以下の設定をしている。<br />
このリンカスクリプトにより、作成されるkernelは仮想アドレス0x80100000で実行され、物理アドレス0x100000にロードされることが分かる。</li>
</ol>
<ul>
<li>出力フォーマットをelf32-i386、出力アーキテクチャをi386、エントリポイントを_startに設定。</li>
<li>textセクションの開始アドレスを0x80100000、ロード先アドレスを0x100000に設定し、オブジェクトファイルのtextセクション等を配置。</li>
<li>オブジェクト内でetextシンボルが定義されていない場合は、textセクションの後ろにetextシンボルを定義する。</li>
<li>textセクションの後ろに、オブジェクトファイルのrodataセクション等を含むrodataセクションを配置。</li>
<li>rodataセクションの後ろに、stabセクションを配置。オブジェクトファイルのstabセクションをシンボル__STAB_BEGIN__と__STAB_END__で挟む。</li>
<li>stabセクションの後ろに、stabstrセクションを配置。オブジェクトファイルのstabstrセクションをシンボル__STABSTR_BEGIN__と__STABSTR_END__で挟む。</li>
<li>stabセクションの後ろの次のページ境界に合うように（0x1000にアラインメント）し、シンボルdataを定義。</li>
<li>シンボルdataの後ろに、各オブジェクトファイルのdataセクションを含むdataセクションを配置。</li>
<li>dataセクションの後ろにシンボルedataを定義。</li>
<li>シンボルedataの後ろに、各オブジェクトファイルのbssセクションを含むbssセクションを配置。</li>
<li>シンボルendを定義。</li>
<li>各オブジェクトファイルのeh_frameセクションとnote.GNU-stackセクションをDISCARDで破棄。</li>
</ul>
<ol start="3">
<li>objdumpでディスアセンブリしてkernel.asmを作成。</li>
<li>objdumpでkernelのシンボルテーブルを出力し、sedで加工してkernel.symを作成。</li>
</ol>
<p>Makefile</p>
<pre><code class="language-Makefile">kernel: $(OBJS) entry.o entryother initcode kernel.ld
	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
	$(OBJDUMP) -S kernel &gt; kernel.asm
	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' &gt; kernel.sym
</code></pre>
<h1><a class="header" href="#3-カーネルのロード" id="3-カーネルのロード">3. カーネルのロード</a></h1>
<p><code>make qemu</code>からentryの実行まで。</p>
<h1><a class="header" href="#31-bootasms" id="31-bootasms">3.1. bootasm.S</a></h1>
<p>bootasm.SではGDTを作り、プロテクトモードへ切り替え、bootmain関数を呼び出す。</p>
<h2><a class="header" href="#a20ラインの有効化" id="a20ラインの有効化">A20ラインの有効化</a></h2>
<p>最初にBIOSが立ち上がり、xv6.imgの最初の510～511バイト目の0x55AAを見てブートセクタだと判断して物理アドレス0x7C00にディスクから1セクタ（512バイト）分読み込む。
つまりxv6.imgのbootblockの部分が0x7C00に読み込まれる。<br />
bootblockの頭の方はbootasm.Sなので、startから実行が開始される。<br />
cli命令で割り込みを無効化する。<br />
axレジスタを使い、各セグメントレジスタ（ds, es, ss）の値を0に初期化する。</p>
<p>次に、キーボードコントローラを使ってアドレスバスのA20ライン以上を使えるように設定を行う。<br />
このA20ラインや、セグメント機構、ページング、割り込み等については<a href="chapter_03/ref_books.html">「はじめて読む486」（書籍2）</a>に詳しく記載されている。
まだアドレスバスが0～19までしか無く、20bitで1MBのアドレスを使用していた時代、0xFFFFFの次0x100000へのアクセスで0x0にアクセスすることができたらしく、その性質を利用したプログラムも書かれていたらしい。その互換性を維持するために起動時はアドレスバスがA19までしか使用できないようになっているらしいので、この上限を開放する必要がある。
A20ラインの有効化にはいくつかの方法があり、その内のひとつとしてキーボードコントローラを使用した方法がある。</p>
<p>キーボードコントローラの仕様については<a href="https://www.win.tue.nl/%7Eaeb/linux/kbd/scancodes.html">「Keyboard scancodes」（リンク7）</a>の「The AT keyboard controller」に載っている。<br />
上記リンクによると、ポート0x64からの読み込みはステータスレジスタの内容となり、書き込みはコマンドとして解釈される。
また、ポート0x60への書き込みはコマンドのデータとして解釈される。</p>
<p>ラベルsata20.1では、ポート0x64からステータス0x2以外が読み出せるまでループしている。
ステータスは0bitがアウトプットバッファを示し、1bitがインプットバッファを示していて、0が空で1がフル。
バッファが空だった場合、ポート0x64にコマンド0xd1を書き込む。0xd1はアウトプットポートにデータを書き込むコマンド。
ラベルsata20.2のループでバッファが空であることを確認できるまで待ち、ポート0x60にデータ0xdfを書き込む。データ0xdfをアウトプットポートに書き込むと、A20ラインが有効になる。</p>
<p>bootasm.S</p>
<pre><code class="language-asm">.code16                       # Assemble for 16-bit mode
.globl start
start:
  cli                         # BIOS enabled interrupts; disable

  # Zero data segment registers DS, ES, and SS.
  xorw    %ax,%ax             # Set %ax to zero
  movw    %ax,%ds             # -&gt; Data Segment
  movw    %ax,%es             # -&gt; Extra Segment
  movw    %ax,%ss             # -&gt; Stack Segment

  # Physical address line A20 is tied to zero so that the first PCs 
  # with 2 MB would run software that assumed 1 MB.  Undo that.
seta20.1:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.1

  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64
  outb    %al,$0x64

seta20.2:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.2

  movb    $0xdf,%al               # 0xdf -&gt; port 0x60
  outb    %al,$0x60
</code></pre>
<h2><a class="header" href="#gdtの作成とロード" id="gdtの作成とロード">GDTの作成とロード</a></h2>
<p>プロテクトモードに切り替える準備をする。<br />
プロテクトモードのセグメント機構ではセグメントディスクリプタを使うので、事前にGDTを作ってlgdt命令で設定する必要がある。GDTに関しても<a href="chapter_03/ref_books.html">「はじめて読む486」（書籍2）</a>に詳しく記載されている。<br />
lgdt命令ではgdtrにGDTのサイズとアドレスをセットする。
サイズは2バイトで、ラベル間の差を取って（gtddesc - gdt - 1）求める。
アドレスにはgdtラベルのアドレスをセットする。<br />
gdtラベルからGDTのエントリが書かれてる。全部で3エントリ。セグメントディスクリプタを作成するSEG_ASMマクロはasm.hに定義されている。
p2align 2で2 * 2 = 4バイトでアラインメントする。<br />
セグメントディスクリプタの構造はプロセッサのマニュアル<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」（リンク8）</a>の「vol.3A 3.4.5 Segment Descriptors」に記載されてる。</p>
<p>作成されるセグメントディスクリプタの内容は、ビルドで作成されたbootblockバイナリを見て、マニュアルの図と照らし合わせるとわかりやすい。
SEG_ASMマクロと引数の一部を電卓で計算すると、コードセグメントディスクリプタの方に値0x9Aが入っているのが分かるので、bootblockをxxdで開いてlessにパイプして9aでサーチすると位置0x60にGDTを見つけることができる。<br />
GDTに作成される3つのエントリは以下のようになっている。<br />
エントリ1: NULL。8バイト全て0。<br />
エントリ2: コードセグメントディスクリプタ。値は16進数で FF FF 00 00 00 9A CF 00。<br />
エントリ3: データセグメントディスクリプタ。値は16進数で FF FF 00 00 00 92 CF 00。<br />
コードセグメントディスクリプタの値はリミット値が0xFFFFF、セグメントベースが0x00000000、属性が0x9AC。属性は以下のようになってる。<br />
type 1100<br />
S    0<br />
DPL  01<br />
P    1<br />
AVL  1<br />
O    0<br />
D    0<br />
G    1<br />
リミット値は0xFFFFFだけど、Gフラグが1だからページ単位になって4K倍されるので0xFFFFF * 4096 = 4GB。
データセグメントディスクリプタの値もコードセグメントディスクリプタとだいたい同じになっている。属性は0x92C。</p>
<p>bootasm.S</p>
<pre><code class="language-asm"># Bootstrap GDT
.p2align 2                                # force 4 byte alignment
gdt:
  SEG_NULLASM                             # null seg
  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg
  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg

gdtdesc:
  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
  .long   gdt                             # address gdt
</code></pre>
<p>asm.h</p>
<pre><code class="language-asm">#define SEG_NULLASM                                             \
        .word 0, 0;                                             \
        .byte 0, 0, 0, 0

// The 0xC0 means the limit is in 4096-byte units
// and (for executable segments) 32-bit mode.
#define SEG_ASM(type,base,lim)                                  \
        .word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);      \
        .byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),         \
                (0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)

#define STA_X     0x8       // Executable segment
#define STA_W     0x2       // Writeable (non-executable segments)
#define STA_R     0x2       // Readable (executable segments)
</code></pre>
<h2><a class="header" href="#プロテクトモードへの切り替え" id="プロテクトモードへの切り替え">プロテクトモードへの切り替え</a></h2>
<p>cr0のプロテクトモード有効フラグ（0bit）を立ててプロテクトモードに切り替える。
GDTのコードセグメントディスクリプタを使ってプロテクトモードでの実行を開始するために、ファージャンプをする。csレジスタの値はファージャンプでなければ変更できないため。
セグメントディスクリプタは1エントリ8バイトなので<code>ljmp $8, $start32</code>で、NULLの次のコードセグメントディスクリプタを指定する。</p>
<p>bootasm.S</p>
<pre><code class="language-asm">  # Switch from real to protected mode.  Use a bootstrap GDT that makes
  # virtual addresses map directly to physical addresses so that the
  # effective memory map doesn't change during the transition.
  lgdt    gdtdesc
  movl    %cr0, %eax
  orl     $CR0_PE, %eax
  movl    %eax, %cr0

//PAGEBREAK!
  # Complete the transition to 32-bit protected mode by using a long jmp
  # to reload %cs and %eip.  The segment descriptors are set up with no
  # translation, so that the mapping is still the identity mapping.
  ljmp    $(SEG_KCODE&lt;&lt;3), $start32
</code></pre>
<p>mmu.h</p>
<pre><code class="language-asm">#define SEG_KCODE 1  // kernel code
#define SEG_KDATA 2  // kernel data+stack
</code></pre>
<p>start32ラベルから32bit命令で実行が始まる。<br />
ds, es, ssにデータセグメントディスクリプタを設定する。<br />
fs, gsに0を設定する。<br />
espにstartのアドレスを設定する。startは0x7C00なのでそこから下に向かってスタックが伸びていくことになる。<br />
bootmain関数を呼び出す。bootmain関数はbootmain.cに定義されいる。</p>
<p>bootasm.S</p>
<pre><code class="language-asm">.code32  # Tell assembler to generate 32-bit code now.
start32:
  # Set up the protected-mode data segment registers
  movw    $(SEG_KDATA&lt;&lt;3), %ax    # Our data segment selector
  movw    %ax, %ds                # -&gt; DS: Data Segment
  movw    %ax, %es                # -&gt; ES: Extra Segment
  movw    %ax, %ss                # -&gt; SS: Stack Segment
  movw    $0, %ax                 # Zero segments not ready for use
  movw    %ax, %fs                # -&gt; FS
  movw    %ax, %gs                # -&gt; GS

  # Set up the stack pointer and call into C.
  movl    $start, %esp
  call    bootmain
</code></pre>
<p>もしもbootmainがリターンした場合、ポート0x8a00にデータ0x8ae0を送る。<br />
Bochsのマニュアル<a href="http://bochs.sourceforge.net/doc/docbook/development/index.html">「Bochs Developers Guide」（リンク9）</a>の「Chapter 3. Advanced debugger usage」から、ポート0x8A00はコマンドレジスタのサーバになっていて、コマンド0x8ae0はデバッガプロンプトに戻ることが分かる。そしてデバッガプロンプトに戻るということはCtrl-Cと同義であると書いてある。
デバッガプロンプトに戻った後、無限ループする。</p>
<p>bootasm.S</p>
<pre><code class="language-asm">  # If bootmain returns (it shouldn't), trigger a Bochs
  # breakpoint if running under Bochs, then loop.
  movw    $0x8a00, %ax            # 0x8a00 -&gt; port 0x8a00
  movw    %ax, %dx
  outw    %ax, %dx
  movw    $0x8ae0, %ax            # 0x8ae0 -&gt; port 0x8a00
  outw    %ax, %dx
spin:
  jmp     spin
</code></pre>
<h1><a class="header" href="#32-bootmain関数" id="32-bootmain関数">3.2. bootmain関数</a></h1>
<p>この関数はディスクからカーネル（elfバイナリ）を物理アドレス0x100000にロードし、entry関数を実行する。</p>
<p><a href="https://kkmtyyz.github.io/xv6-notebook/chapter_02/02_01_xv6_img.html">「2.1. ターゲットxv6.img」</a>で見たように、kernelは1セクタ目から存在している。<br />
readseg関数で1セクタ目から4096バイト分をelfhdrポインタに読み込む。
ここでは読み込みを開始するオフセットに0を渡しているが、readseg関数は読み込みを1セクタ目から開始するので問題ない。<br />
マジックナンバーを確認し、読み込んだデータが少なくともelfヘッダを持っていることを確認する。</p>
<p>elfの構造に関しては<a href="chapter_03/ref_books.html">「リンカ・ローダ 実践開発テクニック」（書籍1）</a>に詳しく記載されている。<br />
読み込んだデータ（カーネル）から、プログラムヘッダを取得する。elfヘッダのアドレス（0x10000）にelfhdr構造体のphoffフィールド（プログラムヘッダのオフセット）を加算することでプログラムヘッダが始まるアドレスが求められる。<br />
プログラムヘッダの個数はelfhdr構造体のphnumフィールドから得られる。<br />
プログラムヘッダの開始アドレスと個数が分かったので、for文で各プログラムヘッダをproghdr構造体に取り出し、以下のようにセグメントをディスクから読み込む。</p>
<ol>
<li>プログラムヘッダからロード先物理アドレス（paddrフィールド）を取得する。</li>
<li>readseg関数でロード先物理アドレスに、ディスク上のセグメント開始位置（offフィールド）からセグメントサイズ（fileszフィールド）の分だけ読み込む。</li>
<li>もしも、セグメントがメモリ上に展開されるサイズ（memszフィールド）が、セグメントサイズ（fileszフィールド）よりも大きい場合、stosb関数でセグメントの後ろをメモリ上に展開されるサイズまで0埋めする。</li>
</ol>
<p>これでカーネルの全てのセグメントがメモリ上の適切な位置にロードされた。<br />
elfバイナリ（カーネル）のエントリーポイントをelfヘッダのentryフィールドから取得する。関数として呼び出すため、関数ポインタにキャストして取得している。ここではエントリーポイントはentry.Sの_startラベル。</p>
<p>最後にエントリーポイントを関数として呼び出し、カーネルの実行を開始する。</p>
<p>elf.h</p>
<pre><code class="language-c">#define ELF_MAGIC 0x464C457FU  // &quot;\x7FELF&quot; in little endian

// File header
struct elfhdr {
  uint magic;  // must equal ELF_MAGIC
  uchar elf[12];
  ushort type;
  ushort machine;
  uint version;
  uint entry;
  uint phoff;
  uint shoff;
  uint flags;
  ushort ehsize;
  ushort phentsize;
  ushort phnum;
  ushort shentsize;
  ushort shnum;
  ushort shstrndx;
};

// Program section header
struct proghdr {
  uint type;
  uint off;
  uint vaddr;
  uint paddr;
  uint filesz;
  uint memsz;
  uint flags;
  uint align;
};
</code></pre>
<p>bootmain.c</p>
<pre><code class="language-c">void
bootmain(void)
{
  struct elfhdr *elf;
  struct proghdr *ph, *eph;
  void (*entry)(void);
  uchar* pa;

  elf = (struct elfhdr*)0x10000;  // scratch space

  // Read 1st page off disk
  readseg((uchar*)elf, 4096, 0);

  // Is this an ELF executable?
  if(elf-&gt;magic != ELF_MAGIC)
    return;  // let bootasm.S handle error

  // Load each program segment (ignores ph flags).
  ph = (struct proghdr*)((uchar*)elf + elf-&gt;phoff);
  eph = ph + elf-&gt;phnum;
  for(; ph &lt; eph; ph++){
    pa = (uchar*)ph-&gt;paddr;
    readseg(pa, ph-&gt;filesz, ph-&gt;off);
    if(ph-&gt;memsz &gt; ph-&gt;filesz)
      stosb(pa + ph-&gt;filesz, 0, ph-&gt;memsz - ph-&gt;filesz);
  }

  // Call the entry point from the ELF header.
  // Does not return!
  entry = (void(*)(void))(elf-&gt;entry);
  entry();
}
</code></pre>
<p>プログラムヘッダとセクションヘッダの情報はobjdumpで確認できるので、以下のようにここで処理されているプログラムヘッダの値を確認できる。<br />
プログラムヘッダは次の3エントリ。仮想アドレスと物理アドレスは<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_02/02_04_kernel.html">「2.4. ターゲットkernel」</a>で見たリンカスクリプトkernel.ldにより設定されている。</p>
<ol>
<li>textセクション。物理アドレス0x100000にロードする。</li>
<li>dataセクション。物理アドレス0x108000にロードする。</li>
<li>スタック。サイズが0。</li>
</ol>
<p><code>objdump -ph kernel | less</code>の出力結果</p>
<pre><code>kernel:     file format elf32-i386

Program Header:
    LOAD off    0x00001000 vaddr 0x80100000 paddr 0x00100000 align 2**12
         filesz 0x0000788c memsz 0x0000788c flags r-x
    LOAD off    0x00009000 vaddr 0x80108000 paddr 0x00108000 align 2**12
         filesz 0x00002516 memsz 0x0000d4a8 flags rw-
   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
         filesz 0x00000000 memsz 0x00000000 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006e92  80100000  00100000  00001000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       000009ec  80106ea0  00106ea0  00007ea0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00002516  80108000  00108000  00009000  2**12
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          0000af88  8010a520  0010a520  0000b516  2**5
                  ALLOC
  4 .debug_line   00002694  00000000  00000000  0000b516  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000104e2  00000000  00000000  0000dbaa  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000390e  00000000  00000000  0001e08c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 000003a8  00000000  00000000  000219a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00005239  00000000  00000000  00021d48  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 00000748  00000000  00000000  00026f81  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000e48  00000000  00000000  000276c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002d  00000000  00000000  00028511  2**0
                  CONTENTS, READONLY
</code></pre>
<p>また、elfヘッダのentryフィールドが示すエントリーポイントのアドレスはreadelfで確認できる。
textセクション開始位置の少し後ろ0x10000cにエントリーポイントがある。</p>
<p><code>readelf -h kernel</code></p>
<pre><code>ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x10000c
  Start of program headers:          52 (bytes into file)
  Start of section headers:          149308 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         4
  Size of section headers:           40 (bytes)
  Number of section headers:         16
  Section header string table index: 15
</code></pre>
<h2><a class="header" href="#readseg関数" id="readseg関数">readseg関数</a></h2>
<p>この関数はサイズを指定してディスクからデータを読み込む。</p>
<p>データの読み込み先物理アドレス（pa）と、読み込むバイト数（count）、読み込みを開始するディスクのオフセットバイト数（offset）を引数として受けとる。<br />
ディスクからの読み込みは1セクタ（512バイト）ずつだが、読み込みたいデータがセクタの途中から開始される場合がある。offsetが512で割り切れない場合がそう。
その場合のために、読み込み先アドレスをセクタ内の読み込み開始位置までの分だけ（offset % 512）下げておく。これで引数で与えられた読み込み先アドレスに丁度offsetバイト目のデータが入る。<br />
また、読み込みはセクタ番号を指定して行い、offsetをその番号の指定に使用するため、セクタサイズで割っておく。このとき、1加算することでブートセクタを含まないようにしている。
つまりoffsetの値が0でも、データの読み込みは1セクタ目から開始される。<br />
データの読み込みにはreadsect関数を用いる。</p>
<p>bootmain.c</p>
<pre><code class="language-c">#define SECTSIZE  512

/* 略 */

void
readseg(uchar* pa, uint count, uint offset)
{
  uchar* epa;

  epa = pa + count;

  // Round down to sector boundary.
  pa -= offset % SECTSIZE;

  // Translate from bytes to sectors; kernel starts at sector 1.
  offset = (offset / SECTSIZE) + 1;

  // If this is too slow, we could read lots of sectors at a time.
  // We'd write more to memory than asked, but it doesn't matter --
  // we load in increasing order.
  for(; pa &lt; epa; pa += SECTSIZE, offset++)
    readsect(pa, offset);
}
</code></pre>
<h2><a class="header" href="#readsect関数" id="readsect関数">readsect関数</a></h2>
<p>この関数はセクタを指定してディスクからデータを読み込む。</p>
<p>IOポートの読み書きにはinb関数やoutb関数を使用する。
ポート番号の意味は<a href="https://wiki.osdev.org/I/O_Ports">「OSDev I/O Ports」（リンク10）</a>にリストされている。
また、個々のポートの働きに関しては<a href="http://bochs.sourceforge.net/techspec/PORTS.LST">「XT, AT and PS/2	 I/O port addresses」（リンク11）</a>に詳しく載っている。<br />
ディスクコントローラの読み書きを行う前に、waitdisk関数を使用してディスクの準備ができるまで待機する。
waitdisk関数はwhileループを使い、ディスクコントローラのステータスレジスタ（0x1F7）の6, 7bitが1, 0でなくなるまで待つ。6bitはディスクのreadyを示し、7bitはコントローラがコマンドを実行中かどうかを示している。つまり状態がreadyかつ、コマンド実行中でなくなるまで待機する。<br />
ポート0x1F7は読み込み時にはステータスレジスタ、書き込み時にはコマンドレジスタへのアクセスとなる。</p>
<p>readsect関数は読み込み先アドレス（dst）とセクタ番号（offset）を引数として受け取る。<br />
ポート0x1F2から0x1F7に書き込みを行い、以下の内容のコマンドを発行する。<br />
0x1F2: 1セクタ分<br />
0x1F3: offset番目のセクタ<br />
0x1F4, 0x1F5: offsetの3バイト目 + offsetの2バイト目で表されるシリンダー<br />
0x1F6: offsetの4バイト目のビットで示されるヘッド<br />
0x1F7: セクタをリードする（再試行ありで）<br />
コマンド実行終了までwaitdisk関数で待機し、insl関数でデータレジスタ（0x1f0）からdstに512 / 4 = 128 * 4バイト = 512バイト読み込む。</p>
<p>bootmain.c</p>
<pre><code class="language-c">void
waitdisk(void)
{
  // Wait for disk ready.
  while((inb(0x1F7) &amp; 0xC0) != 0x40)
    ;
}

// Read a single sector at offset into dst.
void
readsect(void *dst, uint offset)
{
  // Issue command.
  waitdisk();
  outb(0x1F2, 1);   // count = 1
  outb(0x1F3, offset);
  outb(0x1F4, offset &gt;&gt; 8);
  outb(0x1F5, offset &gt;&gt; 16);
  outb(0x1F6, (offset &gt;&gt; 24) | 0xE0);
  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors

  // Read data.
  waitdisk();
  insl(0x1F0, dst, SECTSIZE/4);
}
</code></pre>
<h2><a class="header" href="#inb関数outb関数insl関数" id="inb関数outb関数insl関数">inb関数、outb関数、insl関数</a></h2>
<p>inb関数はポートから1バイト読み込む。<br />
outb関数はポートに1バイト書き込む。<br />
insl関数はポートから指定回数分だけ4バイトずつ読み込む。</p>
<p>これらの関数ではインラインアセンブリを使用する。GCCのインラインアセンブリについては<a href="https://gcc.gnu.org/onlinedocs/gcc-6.5.0/gcc/">「Using the GNU Compiler Collection (GCC)」（リンク3）</a>の<a href="https://gcc.gnu.org/onlinedocs/gcc-6.5.0/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">「6.44 How to Use Inline Assembly Language in C Code」</a>で説明されている。<br />
また、x86の命令については<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」（リンク8）</a>の「Vol.2 Instruction Set Reference, A-Z」で確認できる。</p>
<p>x86.h</p>
<pre><code class="language-c">static inline uchar
inb(ushort port)
{
  uchar data;

  asm volatile(&quot;in %1,%0&quot; : &quot;=a&quot; (data) : &quot;d&quot; (port));
  return data;
}

static inline void
insl(int port, void *addr, int cnt)
{
  asm volatile(&quot;cld; rep insl&quot; :
               &quot;=D&quot; (addr), &quot;=c&quot; (cnt) :
               &quot;d&quot; (port), &quot;0&quot; (addr), &quot;1&quot; (cnt) :
               &quot;memory&quot;, &quot;cc&quot;);
}

static inline void
outb(ushort port, uchar data)
{
  asm volatile(&quot;out %0,%1&quot; : : &quot;a&quot; (data), &quot;d&quot; (port));
}
</code></pre>
<p>insl関数の動きを見ると、以下のようになっている。<br />
cld命令でEFLAGSのDFフラグを0にすることで、文字列操作が行われるとesiとediがインクリメントされるようになる。このため出力先edi(addr)が毎回4バイトずつずれてくれる。<br />
拡張インラインアセンブリの入力にある数字（ここでは0と1）は、番号と一致するオペランドを使うことを示している。
つまりここでは出力が「”=D(addr), “=c”(cnt)」なので、入力は「”d”(port), “D”(addr), “c”(cnt)」と書き直せる。ediとecx
が入力としても出力としても使用される。<br />
insl命令はedxの示すポートから4バイトをediに読み込む。
また、命令にrepがつくと、文字列操作の実行毎にカウントレジスタ（ecx）がデクリメントされ、指定された回数だけ命令をリピートするようになる。
ここで、一度出力と入力を整理する。<br />
出力: edi(addr), ecx(cnt)<br />
入力: edx(port), edi(addr), ecx(cnt)<br />
insl命令では出力: edi(addr)と入力: edx(port)を使う。rep命令はecxを使う。<br />
一見入力のedi(addr)とecx(cnt)が不要に見える。ディスアセンブリされたbootblock.asmを見ると、この部分は次のようになっていて、入力としてのediとecxはますます不要に思える。</p>
<p>bootblock.asm</p>
<pre><code class="language-asm">  asm volatile(&quot;cld; rep insl&quot; :
    7ce4:	8b 7d 08             	mov    0x8(%ebp),%edi
    7ce7:	b9 80 00 00 00       	mov    $0x80,%ecx
    7cec:	ba f0 01 00 00       	mov    $0x1f0,%edx
    7cf1:	fc                   	cld    
    7cf2:	f3 6d                	rep insl (%dx),%es:(%edi)
  insl(0x1F0, dst, SECTSIZE/4);
</code></pre>
<p>しかし、<a href="https://programmersought.com/article/74671233226/">「ProgrammerSought Gnu embedded assembly, inline assembly detailed introduction」（リンク12）</a>によると、repでループする過程において、ループ毎のedi(addr)とecx(cnt)が同一のものであるということをコンパイラに伝えるために必要らしい。<br />
このrepを使用したパターンは今後も出てくる。</p>
<h2><a class="header" href="#stosb関数" id="stosb関数">stosb関数</a></h2>
<p>この関数は値（data）を指定バイト分（cnt）だけアドレス（addr）に書き込む。</p>
<p>repを使用したパターンなので、insl関数と同様の動きになる。</p>
<p>x86.h</p>
<pre><code class="language-c">&gt; 42 static inline void
&gt; 43 stosb(void *addr, int data, int cnt)
&gt; 44 {
&gt; 45   asm volatile(&quot;cld; rep stosb&quot; :
&gt; 46                &quot;=D&quot; (addr), &quot;=c&quot; (cnt) :
&gt; 47                &quot;0&quot; (addr), &quot;1&quot; (cnt), &quot;a&quot; (data) :
&gt; 48                &quot;memory&quot;, &quot;cc&quot;);
&gt; 49 }
</code></pre>
<p>これで物理アドレス0x100000にカーネルをロードすることができた。</p>
<h1><a class="header" href="#4-ページング機構の有効化" id="4-ページング機構の有効化">4. ページング機構の有効化</a></h1>
<p>entry.Sからmain関数の実行まで。</p>
<h1><a class="header" href="#41-entrys" id="41-entrys">4.1. entry.S</a></h1>
<p>entry.Sではページングを有効化し、ページディレクトリを作成して、main関数を呼び出す。</p>
<p>エントリーポイントは<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_02/02_04_kernel.html">「2.4. ターゲットkernel」</a>で見たリンカスクリプトkernel.ldにより_startに設定されている。_startのアドレスは0x10000cだったことを<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_03/03_02_bootmain.html">3.2. bootmain関数</a>で確認した。<br />
今、カーネルを実行していくためにentry.Sのentryラベルから実行を開始したい。
しかし、リンカスクリプトによりカーネルは仮想アドレス0x80100000で実行されるようにリンクされている。
これは<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">「xv6 a simple, Unix-like teaching operating system」</a>の「Figure 1-3. Layout of a Virtual address space」のように、仮想アドレスの上の方にカーネルを置きたいからである。
このためシンボルのアドレスを見ると、entryは0x8010000cで実行されるようになっている。
しかし、kernelのtextのロード先は物理アドレス0x100000なので、実際にはentryは0x100000の近くに配置されている。
なので、<code>V2P_WO(entry)</code>でentryの実際のアドレスを求め、_startのアドレス0x10000cに代入することでentryを実行する。<br />
以降同様の目的でV2P_WOマクロを度々使用する。</p>
<p><code>readelf -s kernel | grep -e start -e entry</code></p>
<pre><code>    46: 801026e6   402 FUNC    LOCAL  DEFAULT    1 idestart
    75: 8010393f   196 FUNC    LOCAL  DEFAULT    1 startothers
   131: 8010000c     0 NOTYPE  GLOBAL DEFAULT    1 entry
   348: 8010a000  4096 OBJECT  GLOBAL DEFAULT    4 entrypgdir
   349: 0010000c     0 NOTYPE  GLOBAL DEFAULT    1 _start
   391: 0000008a     0 NOTYPE  GLOBAL DEFAULT  ABS _binary_entryother_size
   429: 8010b4ec     0 NOTYPE  GLOBAL DEFAULT    4 _binary_entryother_start
   492: 8010b4c0     0 NOTYPE  GLOBAL DEFAULT    4 _binary_initcode_start
   504: 8010b576     0 NOTYPE  GLOBAL DEFAULT    4 _binary_entryother_end
   560: 80103022   227 FUNC    GLOBAL DEFAULT    1 lapicstartap
</code></pre>
<p>memlayout.h</p>
<pre><code class="language-c">#define KERNBASE 0x80000000         // First kernel virtual address

/* 略 */

#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
</code></pre>
<p>entry.S</p>
<pre><code class="language-asm">.globl _start
_start = V2P_WO(entry)

# Entering xv6 on boot processor, with paging off.
.globl entry
entry:
</code></pre>
<p>ページング機構を有効にする。<br />
なお、ページング機構を有効にしてもセグメント機構は無効にならない。
セグメント機構は無効にできないので常に有効になっている。
ページサイズは通常4kBだが、cr4の4bitを1にすると4MBにできる。ここでは4MBページングを有効にする。
<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」</a>の「Vol.3A 4.3 32-BIT PAGING」にページングに関して記載されているが、cr4.PSEが何bitなのかが分からなかった。
しかし、<a href="https://en.wikipedia.org/wiki/Control_register">「Wikipedia Control register」（リンク13）</a>によると4bitがPSEらしく、実際コードもそうなっている。</p>
<p>ページディレクトリには、main.cに定義されているentrypgdirを使う。<br />
ページング機構ではページディレクトリのアドレスをcr3に設定することになっているため、entrypgdirの物理アドレスを設定する。
ページディレクトリentrypgdirは、0番と512番の2つのエントリを持つ。
各エントリがページを指しており、ここでは0番目も512番目も同じ0ページ目（物理アドレス0から4MB分）を指している。
また、ページがメモリ上に存在し（PTE_P）、書き込み可能で（PTE_W）、グローバルなページである（PTE_PS）ことを示している。
これらページディレクトリエントリの各部位の意味や、仮想アドレスの変換方法についてはSDMの「Vol.3A 4.3 32-Bit Paging」に図付きで記述されている。
4MBページでの仮想アドレスの変換方法はSMDの「Figure 4-3. Linear-Address Translation to a 4-MByte Page using 32-bit Paging」の通り。
仮想アドレスの上位10bitがページディレクトリのエントリ番号を示しており、今回はページディレクトリエントリのフラグ部分以外が0なので、ページフレーム0の物理アドレス0x0からページが開始される。</p>
<p>512エントリ目はこの後main関数以降の実行アドレスが高い（0x8000000等）ため必要であり。
0エントリ目はページングを有効にした瞬間からページング機構を用いたアドレス変換が始まるので、低い位置で動いている今（0x100000等）必要となる。</p>
<p>cr0の31bitを1にしてページング機構を有効にし、16bitも1にして書き込み可能ページへの書き込みを特権レベル0でも禁止する。</p>
<p>main関数を実行する前に、今後使用するスタックを準備する。<br />
.commでスタック分の領域が作られ、KSTACKSIZEが4096なのでスタックサイズは4kB。
スタックは上から下に伸びるので、espにはstack + 4096したアドレスを設定する。
.commなのでbssセクションに作成される。リンカスクリプトではbssセクションは後ろの方に作ったので、カーネルの後ろ、データのさらに後ろをスタックとして使用することになる。</p>
<p>memlayout.h</p>
<pre><code class="language-c">#define KERNBASE 0x80000000         // First kernel virtual address

/* 略 */

#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
</code></pre>
<p>param.h</p>
<pre><code class="language-c">#define KSTACKSIZE 4096  // size of per-process kernel stack
</code></pre>
<p>entry.S</p>
<pre><code class="language-asm">.globl _start
_start = V2P_WO(entry)

# Entering xv6 on boot processor, with paging off.
.globl entry
entry:
  # Turn on page size extension for 4Mbyte pages
  movl    %cr4, %eax
  orl     $(CR4_PSE), %eax
  movl    %eax, %cr4
  # Set page directory
  movl    $(V2P_WO(entrypgdir)), %eax
  movl    %eax, %cr3
  # Turn on paging.
  movl    %cr0, %eax
  orl     $(CR0_PG|CR0_WP), %eax
  movl    %eax, %cr0

  # Set up the stack pointer.
  movl $(stack + KSTACKSIZE), %esp

  # Jump to main(), and switch to executing at
  # high addresses. The indirect call is needed because
  # the assembler produces a PC-relative instruction
  # for a direct jump.
  mov $main, %eax
  jmp *%eax

.comm stack, KSTACKSIZE
</code></pre>
<p>main.c</p>
<pre><code class="language-c">__attribute__((__aligned__(PGSIZE)))
pde_t entrypgdir[NPDENTRIES] = {4MB
  // Map VA's [0, 4MB) to PA's [0, 4MB)
  [0] = (0) | PTE_P | PTE_W | PTE_PS,
  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
  [KERNBASE&gt;&gt;PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
};
</code></pre>
<p>mmu.h</p>
<pre><code class="language-c">#define NPDENTRIES      1024    // # directory entries per page directory
#define PGSIZE          4096    // bytes mapped by a page
#define PDXSHIFT        22      // offset of PDX in a linear address
// Page table/directory entry flags.
#define PTE_P           0x001   // Present
#define PTE_W           0x002   // Writeable
#define PTE_U           0x004   // User
#define PTE_PS          0x080   // Page Size
</code></pre>
<p>entry.Sの最後、main関数にジャンプする。<br />
main関数が実際にロードされているアドレスはELFのテキストセグメントを0x100000に読み込んだので、おそらくそのちょっと先くらいだろう。
仮想アドレスはreadelfで確認すると0x80103853になっている。</p>
<p><code>readelf -s kernel | grep main</code></p>
<pre><code>    73: 00000000     0 FILE    LOCAL  DEFAULT  ABS main.c
    76: 801038f8    71 FUNC    LOCAL  DEFAULT    1 mpmain
   415: 80103853   139 FUNC    GLOBAL DEFAULT    1 main
</code></pre>
<p>ページングが有効になっているので、先ほどのページディレクトリを使って以下のようにmainのアドレスが変換される。</p>
<ol>
<li>仮想アドレス0x80103853(main)から上位10bitを取り出す。0b1000 0000 00になる。
10進数で512なので、ページディレクトリの512番目のエントリを使用する。</li>
<li>512番目のエントリはフラグ以外0なので、ページフレームを示すbitも全て0となり、0番目のページフレームを使うことが分かる。</li>
<li>仮想アドレス0x80103853(main)の下位22bitを取り出す。0b01 0000 0011 1000 0101 0011になる。
これは0x103853なので、0ページ目の0x103853に変換される。つまりmainの物理アドレスは0x103853となる。</li>
</ol>
<p>この変換はSDMの「Figure 4-3. Linear-Address Translation to a 4-MByte Page using 32-bit Paging」を見ながら行った。</p>
<p>これでページングを有効にし、main関数にジャンプすることができた。</p>
<h1><a class="header" href="#5-カーネルの実行" id="5-カーネルの実行">5. カーネルの実行</a></h1>
<p>main関数からスケジューラの実行まで。</p>
<h1><a class="header" href="#51-main関数" id="51-main関数">5.1. main関数</a></h1>
<p>ここからは各関数でAPICの設定やAPの起動等を行い、最終的にスケジューラを起動する。</p>
<p>main.c</p>
<pre><code>extern char end[]; // first address after kernel loaded from ELF file

/* 略 */

int
main(void)
{
  kinit1(end, P2V(4*1024*1024)); // phys page allocator
  kvmalloc();      // kernel page table
  mpinit();        // detect other processors
  lapicinit();     // interrupt controller
  seginit();       // segment descriptors
  picinit();       // disable pic
  ioapicinit();    // another interrupt controller
  consoleinit();   // console hardware
  uartinit();      // serial port
  pinit();         // process table
  tvinit();        // trap vectors
  binit();         // buffer cache
  fileinit();      // file table
  ideinit();       // disk 
  startothers();   // start other processors
  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
  userinit();      // first user process
  mpmain();        // finish this processor's setup
}
</code></pre>
<p>先に各関数の概要をまとめておく。</p>
<table><thead><tr><th>関数名</th><th>概要</th></tr></thead><tbody>
<tr><td>kinit1</td><td>大域変数kmemのfreelistに、kernelの終わりから物理アドレス4MBまでを追加する。</td></tr>
<tr><td>kvmalloc</td><td>カーネル用のページディレクトリとPDE、PTEを作成して切り替える。</td></tr>
<tr><td>mpinit</td><td>大域変数lapicにLAPICへのアクセスアドレスを設定、各cpu構造体にLAPIC IDを設定、大域変数ioapicidにIOAPIC IDを設定する。</td></tr>
<tr><td>lapicinit</td><td>LAPICを有効にし、スプリアス割り込みを無効化。APICタイマが10000000からバスクロックが進むごとにカウントダウンされ、0になるとIRQ32で割り込みをかけ、再度カウントダウンを始めるよう設定。LINT0とLINT1ピン、パフォーマンスモニタリングカウンタを無効化。割り込みエラーの際にIRQ51で割り込みかけるように設定。ESR、EOIレジスタをリセット。ICRでAPにINIT IPIを送信し、Arb IDをLAPIC IDと同じ値に設定。TPRをリセット。</td></tr>
<tr><td>seginit</td><td>GDTを作成し、ロードする。</td></tr>
<tr><td>picinit</td><td>MPに対応していない古いPICでの割り込みを無効化する。</td></tr>
<tr><td>ioapicinit</td><td>大域変数ioapicにIOAPICへのアクセスアドレスを設定し、IOリダイレクションテーブルの設定を行う。IRQ0～23番がBSPにIRQ32～55番でリダイレクトされるよう設定を行い、それら全てを無効化する。</td></tr>
<tr><td>consoleinit</td><td>devsw配列の1番にコンソール読み書き用の関数を設定し、IOAPICのキーボードコントローラからの割込みのリダイレクトを有効化する（IRQ1からIRQ33へのリダイレクト）。</td></tr>
<tr><td>uartinit</td><td>UARTのFIFOを無効化し、ボーレートを9600、ワードサイズを8bitに初期化。シリアルポートが使用できるか否かを確認し、使用できる場合は「xv6...」という文字列を送信する。</td></tr>
<tr><td>pinit</td><td>ロセステーブルのロックを初期化する。</td></tr>
<tr><td>tvinit</td><td>大域変数idtに256個のゲートディスクリプタを作成する。</td></tr>
<tr><td>binit</td><td>大域変数bcache（バッファキャッシュ）を初期化する。</td></tr>
<tr><td>fileinit</td><td>大域変数ftable（ファイルテーブル）のロックを初期化する。</td></tr>
<tr><td>ideinit</td><td>ディスク1の存在確認をする。ide.cの静的変数havedisk1に値を設定（0ならディスク1は無し、1なら有り）。</td></tr>
<tr><td>startothers</td><td>各APを起動し、GDT、ページング、IDT等の設定を行い、スケジューラを実行する。mpmain関数もここで見る。</td></tr>
<tr><td>kinit2</td><td>大域変数kmemのfreelistに物理アドレス4MB（0x400000）から終わり（0xe000000）までを加え、use_lockフィールドの値を1にする。</td></tr>
<tr><td>userinit</td><td>initcode.Sのプロセスを作成し、プロセステーブルに追加する。</td></tr>
<tr><td>mpmain</td><td>APのときと同様にBSPでも「cpu0: starting 0」をコンソールに出力し、IDTを読み込み、スケジューラを実行する。</td></tr>
</tbody></table>
<h1><a class="header" href="#52-kinit1関数" id="52-kinit1関数">5.2. kinit1関数</a></h1>
<p>この関数は、大域変数kmemのfreelistに、kernelの終わりから物理アドレス4MBまでを追加する。</p>
<p>main関数からはkernelのendシンボルのアドレス（vstart）と、物理アドレス4MBの仮想アドレス（vend）を受け取る。</p>
<p>main.c</p>
<pre><code class="language-c">extern char end[]; // first address after kernel loaded from ELF file

/* 略 */

int
main(void)
{
  kinit1(end, P2V(4*1024*1024)); // phys page allocator
</code></pre>
<p>endは<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_02/02_04_kernel.html">「2.4. ターゲットkernel」</a>で見たリンカスクリプトkernel.ldによりbssセグメントの後ろ、elfの最後に作成されている。
アドレスはreadelfで確認でき、ここでは0x80116528になっている。<br />
物理アドレスにすると0x116528。</p>
<p><code>readelf -s kernel | grep end</code></p>
<pre><code>   257: 801035ae   196 FUNC    GLOBAL DEFAULT    1 end_op
   331: 80116528     0 NOTYPE  GLOBAL DEFAULT    4 end
   352: 8010b4ec     0 NOTYPE  GLOBAL DEFAULT    3 _binary_initcode_end
   503: 8010b576     0 NOTYPE  GLOBAL DEFAULT    3 _binary_entryother_end
</code></pre>
<p>物理アドレスから仮想アドレスへの変換はP2Vマクロを使う。V2Pマクロと同様にカーネルベースアドレスを使って変換する。</p>
<p>memlayout.h</p>
<pre><code class="language-c">#define KERNBASE 0x80000000         // First kernel virtual address

/* 略 */

#define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
</code></pre>
<p>main関数から与えられたアドレスの範囲は、物理アドレスだと0x116528（vstart）から0x400000（vend）。<br />
freelistに加えるためにPGROUNDUPマクロで4kBにアラインメントするので、開始アドレスは0x117000となり0x400000と差を取ると0x2E9AD8 = 0x2E9000で約3MB。</p>
<p>ページは大域変数kmemのfreelistフィールドに持っておく。
freelistフィールドはrun構造体の線形リストになっており、ページが必要な時はこのリストから取得し、解放するときはこのリストに戻すことになる。
kmem構造体はその他に2つのフィールドを持っており、lockフィールドは排他制御に使用し、use_lockフィールドは排他制御の必要性を示す。
use_lockが0のときは排他制御が不要なので、freelistへアクセスする際にkmemのロックを取らない。use_lockはkinit2関数で初めて1に初期化される。<br />
spinlock構造体等を用いた排他制御に関しては、consoleinit関数で見る。</p>
<p>kalloc.c</p>
<pre><code class="language-c">struct run {
  struct run *next;
};

struct {
  struct spinlock lock;
  int use_lock;
  struct run *freelist;
} kmem;
</code></pre>
<p>kinit1関数は、大域変数kmemのロックを初期化し、freelistにアドレスend（vstart）の次のページから物理アドレス0x400000までを追加する。追加されるページは全て1埋めされる。</p>
<p>kalloc.c</p>
<pre><code class="language-c">void
kinit1(void *vstart, void *vend)
{
  initlock(&amp;kmem.lock, &quot;kmem&quot;);
  kmem.use_lock = 0;
  freerange(vstart, vend);
}
</code></pre>
<h2><a class="header" href="#freerange関数" id="freerange関数">freerange関数</a></h2>
<p>この関数は、指定された仮想アドレスの範囲をkmemのfreelistに加える。</p>
<p>freelistに加えられる範囲は、vstartの次の4kB境界から、vendの次の4kB境界までである。<br />
PGROUNDUPマクロは引数として与えられたアドレスの次のページ境界のアドレスを計算する。</p>
<p>mmu.h</p>
<pre><code class="language-c">#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))
</code></pre>
<p>kalloc.c</p>
<pre><code class="language-c">void
freerange(void *vstart, void *vend)
{
  char *p;
  p = (char*)PGROUNDUP((uint)vstart);
  for(; p + PGSIZE &lt;= (char*)vend; p += PGSIZE)
    kfree(p);
}
</code></pre>
<h2><a class="header" href="#kfree関数" id="kfree関数">kfree関数</a></h2>
<p>この関数は、指定された仮想アドレスのページをkmemのfreelistに加える。ページサイズは4kBで内容は全て1で初期化される。</p>
<p>ページの開始アドレス（v）はページサイズで割り切れ、end以上PHYSTOP未満でなければならない。PHYSTOP（0xE000000）はxv6での物理アドレスの上限。この条件を満たさない場合、panic関数を呼び出す。<br />
panic関数はコンソールのロックを取り、パニックした理由とコールスタックをコンソールに出力し、panickedフラグを1にして無限ループに入る。
コンソール出力にはcgaputc関数を使用する。</p>
<p>ページの初期化はmemset関数で1で埋めすることで行う。<br />
kmemのuse_lockフィールドが1のとき、APが起動しており排他制御が必要となるため、freelistにページを加える間、acquire関数とrelease関数でロックの取得と解放を行う。
kinit1関数の呼び出しではuse_lockは0なので、排他制御は行わない。<br />
初期化したページはfreelistの先頭に追加していく。</p>
<p>kalloc.c</p>
<pre><code class="language-c">void
kfree(char *v)
{
  struct run *r;

  if((uint)v % PGSIZE || v &lt; end || V2P(v) &gt;= PHYSTOP)
    panic(&quot;kfree&quot;);

  // Fill with junk to catch dangling refs.
  memset(v, 1, PGSIZE);

  if(kmem.use_lock)
    acquire(&amp;kmem.lock);
  r = (struct run*)v;
  r-&gt;next = kmem.freelist;
  kmem.freelist = r;
  if(kmem.use_lock)
    release(&amp;kmem.lock);
}
</code></pre>
<p>memlayout.h</p>
<pre><code class="language-c">#define PHYSTOP 0xE000000           // Top physical memory
</code></pre>
<h2><a class="header" href="#memset関数" id="memset関数">memset関数</a></h2>
<p>この関数は指定したアドレスに値をnバイト分書き込む。</p>
<p>書き込み先アドレス（dst）と書き込みサイズ（n）が4で割り切れる場合、stosl関数を使用して4バイトずつ書き込みを行う。
割り切れない場合はstosb関数を使って1バイトずつ書き込む。<br />
4バイトずつ書き込む場合は、書き込む値（c）から1バイト分取り出し、それをシフトして4バイト並べた値を書き込む。</p>
<p>stosb関数とstosl関数は<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_03/03_02_bootmain.html#inb%E9%96%A2%E6%95%B0outb%E9%96%A2%E6%95%B0insl%E9%96%A2%E6%95%B0">「3.2. bootmain関数」</a>で見たinsl関数と同様にrepを使用したパターンになっている。</p>
<p>string.c</p>
<pre><code class="language-c">void*
memset(void *dst, int c, uint n)
{
  if ((int)dst%4 == 0 &amp;&amp; n%4 == 0){
    c &amp;= 0xFF;
    stosl(dst, (c&lt;&lt;24)|(c&lt;&lt;16)|(c&lt;&lt;8)|c, n/4);
  } else
    stosb(dst, c, n);
  return dst;
}
</code></pre>
<p>x86.h</p>
<pre><code class="language-c">static inline void
stosb(void *addr, int data, int cnt)
{
  asm volatile(&quot;cld; rep stosb&quot; :
               &quot;=D&quot; (addr), &quot;=c&quot; (cnt) :
               &quot;0&quot; (addr), &quot;1&quot; (cnt), &quot;a&quot; (data) :
               &quot;memory&quot;, &quot;cc&quot;);
}

static inline void
stosl(void *addr, int data, int cnt)
{
  asm volatile(&quot;cld; rep stosl&quot; :
               &quot;=D&quot; (addr), &quot;=c&quot; (cnt) :
               &quot;0&quot; (addr), &quot;1&quot; (cnt), &quot;a&quot; (data) :
               &quot;memory&quot;, &quot;cc&quot;);
}
</code></pre>
<p>これで大域変数kmemのfreelistに約3MB分のページを追加できた。</p>
<h1><a class="header" href="#53-kvmalloc関数" id="53-kvmalloc関数">5.3. kvmalloc関数</a></h1>
<p>この関数はカーネル用のページディレクトリとPDE、PTEを作成してそれに切り替える。<br />
4kBページングへの切り替えもここで行われる。</p>
<p>大域変数kpgdirに1ページ分のメモリを確保し、カーネル用のページディレクトリとする。<br />
ページディレクトリには次の4つのアドレス変換ができるようにPDEとPTEを作成する。</p>
<ol>
<li>仮想アドレス0x80000000～0x800FF000 → 物理アドレス0x0～0xff000</li>
<li>仮想アドレス0x80100000～0x80108000 → 物理アドレス0x100000～0x108000</li>
<li>仮想アドレス0x80109000～0x8DFFF000 → 物理アドレス0x109000～0xEDFFF000</li>
<li>仮想アドレス0xFE000000～ → 物理アドレス0xFE000000～</li>
</ol>
<p>別な書き方をすると、それぞれ以下の領域のアドレスを変換する。</p>
<ol>
<li>I/Oスペース</li>
<li>カーネルのテキストと読み込み専用データ</li>
<li>カーネルのデータとメモリ</li>
<li>メモリマップドI/Oを使用するデバイスのためのスペース</li>
</ol>
<p>この変換は<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">「xv6 a simple, Unix-like teaching operating system」</a>の図2-2のマッピングを実現する。<br />
ページディレクトリの作成はsetupkvm関数で行い、PDEのbitの設定によりここで4MBページから4kBページに切り替わる。<br />
作成したページディレクトリをswitchkvm関数でcr3にロードする。</p>
<p>vm.c</p>
<pre><code class="language-c">pde_t *kpgdir;  // for use in scheduler()

/* 略 */

void
kvmalloc(void)
{
  kpgdir = setupkvm();
  switchkvm();
}
</code></pre>
<h2><a class="header" href="#setupkvm関数" id="setupkvm関数">setupkvm関数</a></h2>
<p>この関数はカーネル用のページディレクトリとPDE、PTEを作成する。</p>
<p>PDEとPTEはkmap構造体の配列（kmap）を基に作成する。<br />
kmap構造体は、仮想アドレス（virt）を物理アドレス（phys_start）にサイズ（phys_end - phys_start）分だけマップすることを示している。
また、その際にPTEの属性（perm）を設定する。<br />
変数dataはリンカスクリプトで作成されたシンボルで、text、rodata、stab、stabstrの後ろのページ境界に定義されている。今回は0x80109000に存在している。</p>
<p><code>readelf -s kernel | grep data</code></p>
<pre><code>   411: 80109000     0 NOTYPE  GLOBAL DEFAULT    3 data
</code></pre>
<p>memlayout.h</p>
<pre><code class="language-c">#define EXTMEM  0x100000            // Start of extended memory
#define PHYSTOP 0xE000000           // Top physical memory
#define DEVSPACE 0xFE000000         // Other devices are at high addresses

// Key addresses for address space layout (see kmap in vm.c for layout)
#define KERNBASE 0x80000000         // First kernel virtual address
#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
</code></pre>
<p>vm.c</p>
<pre><code class="language-c">static struct kmap {
  void *virt;
  uint phys_start;
  uint phys_end;
  int perm;
} kmap[] = {
 { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
 { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
 { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
 { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
};
</code></pre>
<p>setupkvm関数では、はじめにページディレクトリとしてkalloc関数で1ページ割り当て、0埋めする。<br />
デバイスのメモリマップドI/Oに使用されるアドレス（DEVSPACE）よりも、使用できる物理アドレスの上限（PHYSTOP）が大きかった場合、panicする。<br />
for文でkmap配列を走査し、kmap構造体で示された通りにPDEとPTEを作成する。PDEとPTEの作成にはmappages関数を使う。<br />
もしもPDEやPTEの作成に失敗した場合は、freevm関数でページディレクトリに含まれる全てのPDEとPTE、ページを解放する。</p>
<p>defs.h</p>
<pre><code class="language-c">// number of elements in fixed-size array
#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
</code></pre>
<p>vm.c</p>
<pre><code class="language-c">pde_t*
setupkvm(void)
{
  pde_t *pgdir;
  struct kmap *k;

  if((pgdir = (pde_t*)kalloc()) == 0)
    return 0;
  memset(pgdir, 0, PGSIZE);
  if (P2V(PHYSTOP) &gt; (void*)DEVSPACE)
    panic(&quot;PHYSTOP too high&quot;);
  for(k = kmap; k &lt; &amp;kmap[NELEM(kmap)]; k++)
    if(mappages(pgdir, k-&gt;virt, k-&gt;phys_end - k-&gt;phys_start,
                (uint)k-&gt;phys_start, k-&gt;perm) &lt; 0) {
      freevm(pgdir);
      return 0;
    }
  return pgdir;
}
</code></pre>
<h2><a class="header" href="#kalloc関数" id="kalloc関数">kalloc関数</a></h2>
<p>この関数はkmemのfreelistから1ページ割り当てる。</p>
<p>メモリが必要な時はこの先ずっとこの関数を使用して割り当てを行うので、AP起動後は排他制御が行われる。
kmemのfreelistの先頭を取ってきて返す。
freelistが空の場合、中身のないポインタを返す。</p>
<p>kalloc.c</p>
<pre><code class="language-c">char*
kalloc(void)
{
  struct run *r;

  if(kmem.use_lock)
    acquire(&amp;kmem.lock);
  r = kmem.freelist;
  if(r)
    kmem.freelist = r-&gt;next;
  if(kmem.use_lock)
    release(&amp;kmem.lock);
  return (char*)r;
}
</code></pre>
<h2><a class="header" href="#mappages関数" id="mappages関数">mappages関数</a></h2>
<p>この関数はページディレクトリに、仮想アドレスから物理アドレスへの変換が行えるPDEとPTEを作成する。<br />
関数を呼び出す際にページやPTEの範囲を気にする必要はなく、指定した物理アドレスの範囲を指定した仮想アドレスからアクセスできるようにマッピングしてくれる。</p>
<p>ページディレクトリ（pgdir）に、仮想アドレス（va）から物理アドレスの範囲（paからsizeバイト分）へ変換できるPDEとPTEを作成する。
PTEには属性（perm）を設定する。</p>
<p>まず変換範囲の開始仮想アドレス（a）と終了仮想アドレス（last）を求める。
どちらもページサイズにアラインメントされている必要があるので、PGROUNDDOWNマクロを使用する。
PGROUNDDOWNマクロは、<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_02_kinit1.html">「5.2. kinit1関数」</a>で使用したPGROUNDUPマクロと同様の方法で、アドレスから前のページ境界のアドレスを計算する。
0x1000（PGSIZE）から1引いた0xFFFの否定0x000を論理積して4kBにアラインメントする。</p>
<p>mmu.h</p>
<pre><code>&gt; 90 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))
&gt; 91 #define PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))
</code></pre>
<p>次にfor文で開始仮想アドレス（a）から、変換する最後の仮想アドレス（last）までを走査する。ループ毎の処理の流れは以下のよう。</p>
<ol>
<li>仮想アドレスのPTEを取得する。既にページディレクトリにPTEが存在する場合はそれを取得し、存在しない場合は作成する。これはwalkpgdir関数を用いて行う。</li>
<li>PTEが未使用であることを確認する。PTE_Pフラグが0の場合は未使用、1の場合は使用されている。</li>
<li>PTEに物理アドレスの上位20bitと属性bitをセットし、PTE_Pフラグを立てる。</li>
</ol>
<p>これで求めているアドレス変換が完成する。</p>
<p>vm.c</p>
<pre><code class="language-c">static int
mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
{
  char *a, *last;
  pte_t *pte;

  a = (char*)PGROUNDDOWN((uint)va);
  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
  for(;;){
    if((pte = walkpgdir(pgdir, a, 1)) == 0)
      return -1;
    if(*pte &amp; PTE_P)
      panic(&quot;remap&quot;);
    *pte = pa | perm | PTE_P;
    if(a == last)
      break;
    a += PGSIZE;
    pa += PGSIZE;
  }
  return 0;
}
</code></pre>
<h2><a class="header" href="#walkpgdir関数" id="walkpgdir関数">walkpgdir関数</a></h2>
<p>この関数はページディレクトリから、指定された仮想アドレスに対応するPTEを返す。<br />
PTEがすでに存在している場合はそれを返すが、無い場合は引数allocが1の場合に限り新たに作成する。<br />
また、PTEをPDEにセットする際に、読み書きフラグ（1bit）とユーザフラグ（2bit）を立てる。ページサイズフラグ（7bit）は立てないので、ページサイズは4kBとなる。<br />
PDEの構造と各bitの意味は<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」（リンク8）</a>の「Vol.3 4.3 32-BIT PAGING」に書いてある。</p>
<p>ある仮想アドレスが示すPDEのインデックスはPDXマクロで求めることができる。<br />
コメントに仮想アドレスの構造が示されているので分かりやすい。<br />
PDEを指すインデックスは仮想アドレスの22～31bitなので、22bit右シフトし、0b001111111111（0x3FF）で論理積を取ると求められる。
同様にPTEのインデックスはPTXマクロで求めることができる。</p>
<p>mmu.h</p>
<pre><code class="language-c">// A virtual address 'la' has a three-part structure as follows:
//
// +--------10------+-------10-------+---------12----------+
// | Page Directory |   Page Table   | Offset within Page  |
// |      Index     |      Index     |                     |
// +----------------+----------------+---------------------+
//  \--- PDX(va) --/ \--- PTX(va) --/

// page directory index
#define PDX(va)         (((uint)(va) &gt;&gt; PDXSHIFT) &amp; 0x3FF)

// page table index
#define PTX(va)         (((uint)(va) &gt;&gt; PTXSHIFT) &amp; 0x3FF)

/* 略 */

#define PTXSHIFT        12      // offset of PTX in a linear address
#define PDXSHIFT        22      // offset of PDX in a linear address
</code></pre>
<p>ページディレクトリから仮想アドレスの示すPDEを取得し、それが使用済みの場合（PTE_P==1）はページテーブルを取得する。
ページテーブルの取得にはPTE_ADDRマクロを使う。PDEの12～31bitがページテーブルのアドレスを示しており、ページテーブルは4kBでアラインメントされているため、下位12bitを0にするとアドレスが求まる。
このアドレスは物理アドレスなのでPTEへのアクセスはP2Vマクロで仮想アドレスに変換して行う。</p>
<p>mmu.h</p>
<pre><code class="language-c">#define PTE_ADDR(pte)   ((uint)(pte) &amp; ~0xFFF)
</code></pre>
<p>仮想アドレスが示すPDEが未使用（PTE_P==0）かつ、引数allocが真の場合、新たにページテーブルを作成する。
ページテーブルとしてkalloc関数で1ページ分割り当て、内容を0埋めして初期化する。つまり全てのPTEの内容が0の状態。<br />
PDEにページテーブルのアドレス上位20bitと、読み書きフラグとユーザフラグをセットし、PTE_Pフラグを立てる。繰り返しになるが、ページサイズフラグ（7bit）は立てないので、ページサイズは4kBとなる。</p>
<p>最後に、仮想アドレスが示すPTEをPTXマクロを使用してページテーブルから取得し、呼び出し元に返す。</p>
<p>vm.c</p>
<pre><code class="language-c">static pte_t *
walkpgdir(pde_t *pgdir, const void *va, int alloc)
{
  pde_t *pde;
  pte_t *pgtab;

  pde = &amp;pgdir[PDX(va)];
  if(*pde &amp; PTE_P){
    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
  } else {
    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
      return 0;
    // Make sure all those PTE_P bits are zero.
    memset(pgtab, 0, PGSIZE);
    // The permissions here are overly generous, but they can
    // be further restricted by the permissions in the page table
    // entries, if necessary.
    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
  }
  return &amp;pgtab[PTX(va)];
}
</code></pre>
<h2><a class="header" href="#switchkvm関数" id="switchkvm関数">switchkvm関数</a></h2>
<p>この関数はカーネル用のページディレクトリをcr3にロードする。</p>
<p>呼び出し後からはアドレス変換がkpgdirを使用して行われる。<br />
lcr3関数は引数valを汎用レジスタのどれかに入れてcr3にセットする。</p>
<p>vm.c</p>
<pre><code class="language-c">void
switchkvm(void)
{
  lcr3(V2P(kpgdir));   // switch to the kernel page table
}
</code></pre>
<p>x86.h</p>
<pre><code class="language-asm">static inline void
lcr3(uint val)
{
  asm volatile(&quot;movl %0,%%cr3&quot; : : &quot;r&quot; (val));
}
</code></pre>
<h1><a class="header" href="#54-mpinit関数" id="54-mpinit関数">5.4. mpinit関数</a></h1>
<p>この関数は大域変数lapicにLAPICへのアクセスアドレスを設定、各cpu構造体にLAPICのIDを設定、大域変数ioapicidにIOAPICのIDを設定する。</p>
<p>この関数ではマルチプロセッサに関する情報を取得する。<br />
xv6では使用できる最大CPU数をNCPUとして8に定義している。システムで実際に使用可能なCPU数は、大域変数ncpuに保持する。<br />
また、CPUに関する情報を持つ構造体としてcpu構造体が定義されており、配列cpusとして保持している。</p>
<p>param.h</p>
<pre><code class="language-c">#define NCPU          8  // maximum number of CPUs
</code></pre>
<p>proc.h</p>
<pre><code class="language-c">struct cpu {
  uchar apicid;                // Local APIC ID
  struct context *scheduler;   // swtch() here to enter scheduler
  struct taskstate ts;         // Used by x86 to find stack for interrupt
  struct segdesc gdt[NSEGS];   // x86 global descriptor table
  volatile uint started;       // Has the CPU started?
  int ncli;                    // Depth of pushcli nesting.
  int intena;                  // Were interrupts enabled before pushcli?
  struct proc *proc;           // The process running on this cpu or null
};
</code></pre>
<p>mp.c</p>
<pre><code class="language-c">struct cpu cpus[NCPU];
int ncpu;
</code></pre>
<p>マルチプロセッサに関する構造体が定義されているmp.hの1行目に<a href="https://pdos.csail.mit.edu/6.828/2008/readings/ia32/MPspec.pdf">「MultiProcessor Specification Version 1.4」（リンク14）</a>を見るように書いてある。<br />
このMP仕様書によると、プロセッサは1つのBSP（ブートストラッププロセッサ）とその他のAP（アプリケーションプロセッサ）とに分けられ、起動時はBSPが動いている。
各プロセッサはLAPICを有しており、ICC（割り込みコントローラバス）を通してIOAPICと接続されている。
LAPICに振られているIDでプロセッサを区別することが可能。
起動時には全てのAPのLAPICと、全てのIOAPICが無効化されているため、それらを初期化しなければならない。<br />
また、割り込みモードとして、PICモード、仮想配線モード、Symmetric I/Oモードの3つがある。
システムはPICモードか仮想配線モードで開始され、マルチプロセッサでの割り込みを行うためにSymmetric I/Oモードに移行する必要がある。
MP仕様書の「Table 4-1. MP Floating Pointer Structure Fields」にIMCRがない場合は仮想配線モードが実装されていると書いてある。
IMCR（Interrupt Mode Configuration Register）はPICモードの時に使用されるレジスタ。
Symmetric I/Oモードへの移行方法はMP仕様書の「3.6.2.3 Symmetric I/O Mode」によると、IMCRがある場合はそこに0x1を書き込み、IOAPICのリダイレクションテーブルのエントリを有効化することで行える。</p>
<p>メモリ上には、マルチプロセッサに関する情報を取得するために、MPフローティングポインタ構造体と、MP設定テーブルが用意されている（後者はオプション）。<br />
MPフローティングポインタ構造体はシステムのMPに関する基本的な情報を持っており、以下のいずれかの場所にある。</p>
<ol type='a'>
  <li>EBDA（拡張BIOSデータ領域）の最初の1キロバイト</li>
  <li>システムベースメモリの最後の1キロバイト以内のどこか</li>
  <li>0xF0000から0xFFFFFまでのBIOS ROMアドレスのどこか</li>
</ol>
<p>MP設定テーブルの開始アドレスは、MPフローティングポインタ構造体のPHYSICAL ADDRESS POINTERフィールド（4バイト目）が持っている。このフィールドの値が0の場合は、MP設定テーブルは存在しない。<br />
MP設定テーブルはひとつのヘッダ部分と、複数のエントリ部分に分かれている。ヘッダにはMP設定テーブルの基本的な情報を持っている。<br />
基本的なエントリとその構造はMP仕様書の「Table 4-3. Base MP Configuration Table Entry types」に定義されており、以下の5つのエントリがある。各エントリはタイプコード（0バイト目）で識別することが可能。</p>
<ol>
<li>Processor: 0（タイプコード）</li>
<li>Bus: 1</li>
<li>I/O APIC: 2</li>
<li>I/O Interrupt Assignment: 3</li>
<li>Local Interrupt Assignment: 4</li>
</ol>
<p>このエントリとタイプコードに合わせるようにmp.hに定義がある。</p>
<p>mp.h</p>
<pre><code class="language-c">#define MPPROC    0x00  // One per processor
#define MPBUS     0x01  // One per bus
#define MPIOAPIC  0x02  // One per I/O APIC
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source
</code></pre>
<p>mpinit関数は、まずMPフローティングポインタ構造体と、MP設定テーブルを取得する。取得にはmpconfig関数を使う。<br />
MP設定テーブルからLAPICへのアクセスアドレスを取得し、大域変数lapicに設定する。
アドレスはADDRESS OF LOCAL APICフィールド（36バイト目）から取得可能。
LAPICはプロセッサに内臓されているため、各プロセッサが個別に持っているが、MP仕様書によると、各プロセッサは自分のLAPICにアクセスするために同じアドレスにアクセスする。アドレスは同じでもアクセスは自分のLAPICへのものになる。</p>
<p>for文でMP設定テーブルのエントリをポインタpで走査する。<br />
エントリのタイプコード（1バイト目）により処理内容が分かれる。未知のエントリが検出された場合はpanic。</p>
<p><strong>Processerの場合:</strong><br />
大域変数cpus[ncpu]のapicidフィールドにLAPIC IDを設定する。LAPIC IDは、エントリのLOCAL APIC IDフィールド（1バイト目）にある。<br />
次のプロセッサエントリのためにncpuをインクリメントする。<br />
pにエントリのサイズを加えて、ループを継続する。</p>
<p><strong>I/O APICの場合:</strong><br />
大域変数ioapicidにIOAPIC IDを設定する。IOAPIC IDは、エントリのI/O APIC IDフィールド（1バイト目）にある。<br />
pにエントリのサイズを加えて、ループを継続する。</p>
<p><strong>Bus, I/O Interrupt Assignment, Local Interrupt Assignmentの場合:</strong><br />
何もしない。<br />
pにエントリのサイズを加えて、ループを継続する。</p>
<p>全てのエントリの処理が終わった時点で、以下の大域変数が設定されている。<br />
lapic: LAPICへのアクセスアドレスが設定されている。<br />
ncpu: システムで使用できるCPU数が設定されている。<br />
cpus配列: ncpu分のapicidフィールドに各LAPIC IDが設定されている。<br />
ioapicid: IOAPIC IDが設定されている。</p>
<p>mpinit関数の最後の処理、IMCR（Interrupt Mode Configuration Register）がシステムに実装されている場合、Symmetric I/Oモードへの移行準備として、そこに0x1を書き込む。<br />
IMCRの有無は、MPフローティングポインタ構造体のMP FEATURE INFORMATION BYTE 2フィールド（12バイト目）の7bit目が1であればIMCR有り、0なら無しと判断できる。
0から6bit目まではMP仕様で予約されている。
MP仕様書の「3.6.2.1 PIC Mode」によると、IMCRへはポート0x22に0x70を書き込む事でアクセスできる。データの読み書きはポート0x23に行う。
IMCRの内容をそのまま0bitを1にする。</p>
<p>mp.c</p>
<pre><code class="language-c">void
mpinit(void)
{
  uchar *p, *e;
  int ismp;
  struct mp *mp;
  struct mpconf *conf;
  struct mpproc *proc;
  struct mpioapic *ioapic;

  if((conf = mpconfig(&amp;mp)) == 0)
    panic(&quot;Expect to run on an SMP&quot;);
  ismp = 1;
  lapic = (uint*)conf-&gt;lapicaddr;
  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf-&gt;length; p&lt;e; ){
    switch(*p){
    case MPPROC:
      proc = (struct mpproc*)p;
      if(ncpu &lt; NCPU) {
        cpus[ncpu].apicid = proc-&gt;apicid;  // apicid may differ from ncpu
        ncpu++;
      }
      p += sizeof(struct mpproc);
      continue;
    case MPIOAPIC:
      ioapic = (struct mpioapic*)p;
      ioapicid = ioapic-&gt;apicno;
      p += sizeof(struct mpioapic);
      continue;
    case MPBUS:
    case MPIOINTR:
    case MPLINTR:
      p += 8;
      continue;
    default:
      ismp = 0;
      break;
    }
  }
  if(!ismp)
    panic(&quot;Didn't find a suitable machine&quot;);

  if(mp-&gt;imcrp){
    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
    // But it would on real hardware.
    outb(0x22, 0x70);   // Select IMCR
    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  }
}
</code></pre>
<h2><a class="header" href="#mpconfig関数" id="mpconfig関数">mpconfig関数</a></h2>
<p>この関数はメモリからMP設定テーブルを取得する。</p>
<p>MPフローティングポインタ構造体をmpconfig関数で取得し、そのPHYSICAL ADDRESS POINTERフィールド（4バイト目）からMP設定テーブルのアドレスを取得する。<br />
MP設定テーブルのSIGNATUREフィールド（0バイト目）が “PCMP” であることを確認し、M確かにMP設定テーブルであることを確認する。
準拠しているMP仕様のバージョンを確認する。これはMP設定テーブルのSPEC_REVフィールド（9バイト目）から確認でき、<a href="https://pdos.csail.mit.edu/6.828/2008/readings/ia32/MPspec.pdf">「MultiProcessor Specification Version 1.4」（リンク14）</a>の「Table 4-1. MP Floating Pointer Structure Fields」によると0x1がバージョン1.1、0x4がバージョン1.4を示す。<br />
チェックサムの計算を行う。MP設定テーブル全体の値を1バイト単位で合計し、結果が0となることでMP設定テーブルに誤りがないことを確認する。CHECKSUMフィールド（10バイト目）の値は結果が0になるような値が設定されている。<br />
引数pmpにMPフローティングポインタ構造体を代入し、MP設定テーブルを呼び出し元に返す。</p>
<p>mp.c</p>
<pre><code class="language-c">static uchar
sum(uchar *addr, int len)
{
  int i, sum;

  sum = 0;
  for(i=0; i&lt;len; i++)
    sum += addr[i];
  return sum;
}

/* 略 */

static struct mpconf*
mpconfig(struct mp **pmp)
{
  struct mpconf *conf;
  struct mp *mp;

  if((mp = mpsearch()) == 0 || mp-&gt;physaddr == 0)
    return 0;
  conf = (struct mpconf*) P2V((uint) mp-&gt;physaddr);
  if(memcmp(conf, &quot;PCMP&quot;, 4) != 0)
    return 0;
  if(conf-&gt;version != 1 &amp;&amp; conf-&gt;version != 4)
    return 0;
  if(sum((uchar*)conf, conf-&gt;length) != 0)
    return 0;
  *pmp = mp;
  return conf;
}
</code></pre>
<h2><a class="header" href="#mpsearch関数" id="mpsearch関数">mpsearch関数</a></h2>
<p>この関数はメモリからMPフローティングポインタ構造体を取得する。</p>
<p><a href="https://pdos.csail.mit.edu/6.828/2008/readings/ia32/MPspec.pdf">「MultiProcessor Specification Version 1.4」（リンク14）</a>の「3.9 Support for Fault-resilient Booting」に記載されているaからcの方法を順に試し、MPフローティングポインタ構造体を探す。</p>
<ol type='a'>
  <li>EBDA（拡張BIOSデータ領域）の最初の1キロバイト</li>
  <li>システムベースメモリの最後の1キロバイト以内のどこか</li>
  <li>0xF0000から0xFFFFFまでのBIOS ROMアドレスのどこか</li>
</ol>
<p>各範囲の走査にはmpsearch1関数を使用する。</p>
<p>まず最初のif文で方法aを試す。<br />
BIOSからブートローダに移る際のx86のメモリマップは<a href="https://wiki.osdev.org/Memory_Map_(x86)">「OSDev Memory Map (x86)」（リンク15）</a>に記載されている。
それによると、BDAは0x0400から始まり、0x040Eから2バイト分には、4bit右シフトされたEBDAの物理アドレスが入っている。
なので、0x40Fの内容を上位8bit、0x40Eの内容を下位8bitとして、4bit左シフトすると、EBDAの物理アドレスが求められる。</p>
<p>次にelse文で方法bを試す。<br />
システムベースメモリというのはmpsearch関数を読む限りではEBDAの開始アドレスまでを指す。
BDA内、0x0413から2バイト分には、EBDAまでのキロバイト数が記してある。
なので、0x414の内容を上位8bit、0x413の内容を下位8bitとして、1024掛けるとEBDAまでのバイト数になる。
EBDAの手前1キロバイト以内を探す。</p>
<p>最後にreturn文で方法cを試す。</p>
<p>mp.c</p>
<pre><code class="language-c">static struct mp*
mpsearch(void)
{
  uchar *bda;
  uint p;
  struct mp *mp;

  bda = (uchar *) P2V(0x400);
  if((p = ((bda[0x0F]&lt;&lt;8)| bda[0x0E]) &lt;&lt; 4)){
    if((mp = mpsearch1(p, 1024)))
      return mp;
  } else {
    p = ((bda[0x14]&lt;&lt;8)|bda[0x13])*1024;
    if((mp = mpsearch1(p-1024, 1024)))
      return mp;
  }
  return mpsearch1(0xF0000, 0x10000);
}
</code></pre>
<p>mpsearch1関数では与えられた物理アドレスと長さ分の範囲を走査し、MPフローティングポインタ構造体を探す。<br />
MP仕様書の「Table 4-1. MP Floating Pointer Structure Fields」によると、SIGNATUREフィールド（0バイト目）に  ”_MP_” が入っているため、それを頼りに同構造体を探すことができる。
また、CHECKSUMフィールド（10バイト目）により、見つけた領域がMPフローティングポインタ構造体であるか否かを断定できる。
チェックサムの計算方法は<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_04_mpinit.html#mpconfig%E9%96%A2%E6%95%B0">「mpconfig関数」</a>のときと同様。</p>
<p>mp.c</p>
<pre><code class="language-c">// Look for an MP structure in the len bytes at addr.
static struct mp*
mpsearch1(uint a, int len)
{
  uchar *e, *p, *addr;

  addr = P2V(a);
  e = addr+len;
  for(p = addr; p &lt; e; p += sizeof(struct mp))
    if(memcmp(p, &quot;_MP_&quot;, 4) == 0 &amp;&amp; sum(p, sizeof(struct mp)) == 0)
      return (struct mp*)p;
  return 0;
}
</code></pre>
<h2><a class="header" href="#memcmp関数" id="memcmp関数">memcmp関数</a></h2>
<p>引数v1と引数v2の値をnバイトまで比較し、等しい場合は0を、等しくない場合は一致しなかった値のv1 - v2の値を返す。</p>
<p>string.c</p>
<pre><code class="language-c">int
memcmp(const void *v1, const void *v2, uint n)
{
  const uchar *s1, *s2;

  s1 = v1;
  s2 = v2;
  while(n-- &gt; 0){
    if(*s1 != *s2)
      return *s1 - *s2;
    s1++, s2++;
  }

  return 0;
}
</code></pre>
<h1><a class="header" href="#55-lapicinit関数" id="55-lapicinit関数">5.5. lapicinit関数</a></h1>
<p>この関数はLAPICを有効にし、スプリアス割り込みを無効化。APICタイマが10000000からバスクロックが進むごとにカウントダウンされ、0になるとIRQ32で割り込みをかけ、再度カウントダウンを始めるよう設定。LINT0とLINT1ピン、パフォーマンスモニタリングカウンタも無効化。割り込みエラーの際にIRQ51で割り込みを発生するように設定。ESR、EOIレジスタをリセット。ICRでAPにINIT IPIを送信し、Arb IDをLAPIC IDと同じ値に設定。TPRに0を設定する。</p>
<p>LAPICの設定を行うので、<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」（リンク8）</a>の「Vol.3 CHAPTER 10 ADVANCED PROGRAMMABLE INTERRUPT CONTROLLER (APIC)」を参照する。<br />
MPの場合、外部からの割り込みをIOAPICが各LAPICに送信する。
xv6ではIOAPICのIOリダイレクションテーブルのエントリに割り込み先プロセッサのIDを設定し、IRQに応じて特定のプロセッサにリダイレクトする。<br />
内部からの割り込みは、LAPICがLVT（ローカルベクタテーブル）を使用してプロセッサに割り込みを送信する。
ローカル割り込みのソースとしては、プロセッサの割り込みピン（LINT0とLINT1ピン）、APICタイマ、温度センサ、パフォーマンスモニタリングカウンタ、他のプロセッサがある。<br />
ローカルAPICは多くのレジスタを備えており、そのアドレスと名前はIntel-SDMの「Table 10-1 Local APIC Register Address Map」にリストされている。
各レジスタへのアクセスは<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_04_mpinit.html">「5.4. mpinit関数」</a>にてLAPICへのアクセスアドレスを設定した大域変数lapicを通して行う。
レジスタのアドレスをオフセットとして使うことにより、lapic変数から任意のレジスタにアクセスできる。
lapic変数はuint*型なので、バイト単位でオフセットを使用するために4で割る。
例えばLocal APIC ID Register（0xFEE00020）にアクセスする際は、<code>lapic[0x0020 / 4]</code>とする。</p>
<p>LAPICのレジスタへの書き込みにはlapicw関数を使用する。<br />
オフセット（index）で示されるレジスタに値（value）を書き込む。<br />
書き込み完了を待機するために、Local APIC ID Registerの読み込みを行う。</p>
<p>lapic.c</p>
<pre><code class="language-c">// Local APIC registers, divided by 4 for use as uint[] indices.
#define ID      (0x0020/4)   // ID

/* 略 */

static void
lapicw(int index, int value)
{
  lapic[index] = value;
  lapic[ID];  // wait for write to finish, by reading
}
</code></pre>
<p>lapicinit関数は設定項目が多いので、設定項目毎に見ていくことにする。</p>
<p>lapic.c</p>
<pre><code class="language-c">void
lapicinit(void)
{
  if(!lapic)
    return;

  // Enable local APIC; set spurious interrupt vector.
  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));

  // The timer repeatedly counts down at bus frequency
  // from lapic[TICR] and then issues an interrupt.
  // If xv6 cared more about precise timekeeping,
  // TICR would be calibrated using an external time source.
  lapicw(TDCR, X1);
  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
  lapicw(TICR, 10000000);

  // Disable logical interrupt lines.
  lapicw(LINT0, MASKED);
  lapicw(LINT1, MASKED);

  // Disable performance counter overflow interrupts
  // on machines that provide that interrupt entry.
  if(((lapic[VER]&gt;&gt;16) &amp; 0xFF) &gt;= 4)
    lapicw(PCINT, MASKED);

  // Map error interrupt to IRQ_ERROR.
  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);

  // Clear error status register (requires back-to-back writes).
  lapicw(ESR, 0);
  lapicw(ESR, 0);

  // Ack any outstanding interrupts.
  lapicw(EOI, 0);

  // Send an Init Level De-Assert to synchronise arbitration ID's.
  lapicw(ICRHI, 0);
  lapicw(ICRLO, BCAST | INIT | LEVEL);
  while(lapic[ICRLO] &amp; DELIVS)
    ;

  // Enable interrupts on the APIC (but not on the processor).
  lapicw(TPR, 0);
}
</code></pre>
<h2><a class="header" href="#lapicの有効化とスプリアス割り込みベクタの設定" id="lapicの有効化とスプリアス割り込みベクタの設定">LAPICの有効化と、スプリアス割り込みベクタの設定</a></h2>
<p>LAPICは電源投入時やリセット時に無効化されているため、ここで有効化する。<br />
方法は2通りあり、Intel-SDMの「Vol.3 10.4.3 Enabling or Disabling the Local APIC」に記されている。
ここでは2番目のスプリアス割り込みベクタレジスタのフラグを使用する方法をとっている。<br />
レジスタにはアドレス0xFEE000F0（オフセット0xF0）でアクセスでき、各bitの意味はIntel-SDMの「Vol.3 10.9 SPURIOUS INTERRUPT」に記載されている。
APIC Software Enable/Disableビット（8bit）をセットするとLAPICが有効になる。</p>
<p>LAPICの有効化と同時に、スプリアス割り込みに何番のIRQを使用するかを設定する。<br />
スプリアス割り込みは、電気的な干渉やデバイスの誤動作等により期せずして発生した割り込みのことで、スプリアス割り込みベクタレジスタの0～7bitでその際のIRQを設定できる。
ここでは63番をスプリアス割り込みに割り当てている。<br />
教科書<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">「xv6 a simple, Unix-like teaching operating system」（リンク1）</a>の「Code: Assembly trap handlers」によると、x86には256個の割り込みベクタ番号があり、0～31番は除算エラーや無効なアドレスのアクセスによるエラー等に割り当てられていて、32～255番はユーザが定義できるようになっている。
xv6は32～63番をハードウェア割り込みに使用する。システムコールは64番を使用する。
0～31番までの割り込みはIntel-SDMの「Vol.3 Table 6-1. Protected-Mode Exceptions and Interrupts」にリストしてある。
また、traps.hには割り込み番号の一覧が定義されている。</p>
<p>traps.h</p>
<pre><code class="language-c">#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ

/* 略 */

#define IRQ_SPURIOUS    31
</code></pre>
<p>lapic.c</p>
<pre><code class="language-c">#define SVR     (0x00F0/4)   // Spurious Interrupt Vector
  #define ENABLE     0x00000100   // Unit Enable

/* 略 */

  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
</code></pre>
<h2><a class="header" href="#lapicタイマの設定" id="lapicタイマの設定">LAPICタイマの設定</a></h2>
<p>Intel-SDMの「Vol.3 10.5.4 APIC Timer」によると、LAPICには32bitプログラマブルタイマが含まれていて、Divide Configurationレジスタ、Initial Countレジスタ、Current Countレジスタ、LVT Timerレジスタの4つで設定を行う。<br />
動作としては、Initial Countレジスタから値がCurrent Countレジスタにコピーされて、後者がカウントダウンする。
カウントが0になると、タイマ割り込みが発生する。
ここでは以下の4つの設定を行う。</p>
<ul>
<li>タイマの周波数</li>
<li>タイマの動作モードと割り込み番号</li>
<li>タイマの初期値</li>
</ul>
<p>タイマの周波数:<br />
Divide Configurationレジスタ（0x3E0）に0xBを設定する。
このレジスタはその値によって、LAPICタイマの周波数が、プロセッサのバスクロックを何分の一したものにするかを設定する。
Intel-SDMに各bitパターンで設定されるの値が記されている。0b1011（0xB）の場合は1分の1が設定されるので、バスクロックと等しい周波数で動作する。</p>
<p>タイマの動作モードと割り込み番号:
LVT Timerレジスタ（0x320）に0x20020を設定する。
LAPICタイマの動作モードは、このレジスタの18bitと17bitによって決定される。ここではPeriodicモードが設定される。<br />
動作モードは以下の3種類。0b11は予約済み。</p>
<table><thead><tr><th>bit</th><th>モード</th><th>動作</th></tr></thead><tbody>
<tr><td>0b00</td><td>One-shot</td><td>Current Countレジスタの値が0になり、割り込み発生後も0のまま変化しない。</td></tr>
<tr><td>0b01</td><td>Periodic</td><td>Current Countレジスタの値が0になり、割り込み発生後、Initial Countレジスタの値を再びコピーし、継続的にカウントダウンを行う。</td></tr>
<tr><td>0b10</td><td>TSC-Deadline</td><td>Initial Countレジスタが無視され、Current Countレジスタは常に0になり、タイマの動作はIA32_TSC_DEADLINE MSRによって制御される。</td></tr>
</tbody></table>
<p>割り込み番号は32番をタイマ割り込みに割り当てている。</p>
<p>タイマの初期値:<br />
Initial Countレジスタ（0x380）に10000000を設定する。</p>
<p>まとめると、LAPICタイマは、10000000からバスクロックが進むごとにカウントダウンされ、0になるとIRQ32番で割り込みをかける。その後再び10000000からカウントダウンが始まる。</p>
<p>traps.h</p>
<pre><code class="language-c">#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ

#define IRQ_TIMER        0
</code></pre>
<p>lapic.c</p>
<pre><code class="language-c">#define TIMER   (0x0320/4)   // Local Vector Table 0 (TIMER)
  #define X1         0x0000000B   // divide counts by 1
  #define PERIODIC   0x00020000   // Periodic

/* 略 */

#define TICR    (0x0380/4)   // Timer Initial Count
#define TDCR    (0x03E0/4)   // Timer Divide Configuration

/* 略 */

  lapicw(TDCR, X1);
  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
  lapicw(TICR, 10000000);
</code></pre>
<h2><a class="header" href="#lint0ピンとlint1ピンの無効化" id="lint0ピンとlint1ピンの無効化">LINT0ピンとLINT1ピンの無効化</a></h2>
<p>Intel-SDMの「Vol.3 6.3.1 External Interrupts」によると、LINT0ピンとLINT1ピンはLAPICが有効な場合、割り込みに関与するようプログラムすることができる。
xv6では使用しないので無効にするのだと思う。
LINT0ピン（0x350）と、LINT1ピン（0x360）に0x00010000を設定している。
Intel-SDMの「Vol.3 Figure 10-8. Local Vector Table (LVT)」を見ると、16bitはマスクビットで1がMaskedとなっている。</p>
<p>lapic.c</p>
<pre><code class="language-c">#define LINT0   (0x0350/4)   // Local Vector Table 1 (LINT0)
#define LINT1   (0x0360/4)   // Local Vector Table 2 (LINT1)

/* 略 */

  #define MASKED     0x00010000   // Interrupt masked

/* 略 */

  lapicw(LINT0, MASKED);
  lapicw(LINT1, MASKED);
</code></pre>
<h2><a class="header" href="#パフォーマンスモニタリングカウンタの無効化" id="パフォーマンスモニタリングカウンタの無効化">パフォーマンスモニタリングカウンタの無効化</a></h2>
<p>パフォーマンスモニタリングカウンタが実装されている場合に、それを無効化する。<br />
Local APIC Versionレジスタ（0x30）のMax LVT Entry（16～23bit）の値が4以上であれば、実装されている。
この値の意味は、Intel-SDMの「Vol.3 10.4.8 Local APIC Version Register」に記載してあり、LVTエントリの数-1の値が設定されている。
LVTのエントリは同マニュアルの「Vol.3 Figure 10-8 Local Vector Table (LVT)」で確認でき、5番目がパフォーマンスモニタリングカウンタになっている。
なので、4（5-1=4）以上であればパフォーマンスモニタリングカウンタが実装されている。<br />
実装されている場合は、パフォーマンスモニタリングカウンタ（0x340）のマスクビットを立てて無効化する。</p>
<p>lapic.c</p>
<pre><code class="language-c">#define VER     (0x0030/4)   // Version

/* 略 */

#define PCINT   (0x0340/4)   // Performance Counter LVT

/* 略 */

  #define MASKED     0x00010000   // Interrupt masked

/* 略 */

  if(((lapic[VER]&gt;&gt;16) &amp; 0xFF) &gt;= 4)
    lapicw(PCINT, MASKED);
</code></pre>
<p>##LAPICでエラーが生じた際のIRQ番号の設定
LVT Errorレジスタ（0x370）に51を設定する。<br />
このレジスタはIntel-SDMの「Vol.3 10.5.3 Error Handling」によると、LAPICでエラーが生じた際に割り込みを行うIRQ番号を設定することができる。
ここでは51番を設定している。</p>
<p>traps.h</p>
<pre><code class="language-c">#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ

/* 略 */

#define IRQ_ERROR       19
</code></pre>
<p>lapic.c</p>
<pre><code class="language-c">#define ERROR   (0x0370/4)   // Local Vector Table 3 (ERROR)

/* 略 */

  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
</code></pre>
<h2><a class="header" href="#esrをリセット" id="esrをリセット">ESRをリセット</a></h2>
<p>ESR（Error Status Register）（0x280）に0を設定する。
Intel-SDMの「Vol.3 10.5.3 Error Handling」によると、ESRはLAPICの割り込みでエラーが生じた際に検出されたエラーが書き込まれる。
ソースコード内のコメントによるとESRを初期化するためには0を2回書き込む必要があるらしいが、理由は見つけられなかった。</p>
<p>lapic.c</p>
<pre><code class="language-c">#define ESR     (0x0280/4)   // Error Status

/* 略 */

  // Clear error status register (requires back-to-back writes).
  lapicw(ESR, 0);
  lapicw(ESR, 0);
</code></pre>
<h2><a class="header" href="#eoiレジスタをリセット" id="eoiレジスタをリセット">EOIレジスタをリセット</a></h2>
<p>EOI（End Of Interrupt）レジスタ（0xB0）に0を設定する。<br />
Intel-SDMの「Vol.3 10.8.5 Signaling Interrupt Servicing Completion」でこのレジスタについて記載されている。
割り込みハンドラは、割り込み処理の終了時、iret命令の前にEOIレジスタに書き込みを行う必要がある。</p>
<p>lapic.c</p>
<pre><code class="language-c">#define EOI     (0x00B0/4)   // EOI

/* 略 */

  lapicw(EOI, 0);
</code></pre>
<h2><a class="header" href="#icrの設定" id="icrの設定">ICRの設定</a></h2>
<p>ICR（Interrupt Command Register）は64bitなので、LAPICアクセスアドレスのインデックスが32bitずつ0x300と0x310に分かれている。<br />
ICRについては、Intel-SDMの「Vol.3 10.6.1 Interrupt Command Register (ICR)」に記載があり、プロセッサ間割り込みIPI（Inter Processor Interrupts）の送信と設定を行う。各bitの意味は同マニュアルに記載されている。<br />
ここではDestination Shorthand（18, 19bit）とDelivery Mode（8～10bit）、Trigger Mode（15bit）を以下のように設定する。<br />
Destination Shorthand: All Including Self（0b01）。IPIの送信先を自分を含む全てのプロセッサにする。<br />
Delivery Mode: INITモード（0b101）。全てのプロセッサにINIT IPIを送信する。<br />
Trigger Mode: レベルモード（0b1）。INIT level de-assert delivery modeのトリガをレベルに設定する。</p>
<p>上記IPIの送信が終了するまでwhileループする。<br />
ICRのDelivery Status（12bit）が1の時は送信が未完了、0になると送信完了となる。</p>
<p>Intel-SDMの「Vol.3 8.4.4.2 Typical AP Initialization Sequence」によると、起動後、各APはCLI命令とHLT命令が実行された状態になっており、BSPからのINIT IPIを待っている。<br />
同マニュアル「Vol.3 10.6.1 Interrupt Command Register（ICR）」によると、ここではINIT IPIをlevel de-assertで送信することにより、IPIの処理順序を決定するために使われるArb ID（Arbitration ID）をLAPIC IDと同じ値にしている。<br />
また、<a href="https://pdos.csail.mit.edu/6.828/2008/readings/ia32/MPspec.pdf">「MultiProcessor Specification Version 1.4」（リンク14）</a>の「5.2 Integrated APIC Configurations」によると、APはRESETやINITシグナルを受けると、HALT状態になり、OSがSTARTUP IPIを送信するまで停止したままとなる。</p>
<p>lapic.c</p>
<pre><code class="language-c">#define ICRLO   (0x0300/4)   // Interrupt Command
  #define INIT       0x00000500   // INIT/RESET
  #define STARTUP    0x00000600   // Startup IPI
  #define DELIVS     0x00001000   // Delivery status
  #define ASSERT     0x00004000   // Assert interrupt (vs deassert)
  #define DEASSERT   0x00000000
  #define LEVEL      0x00008000   // Level triggered
  #define BCAST      0x00080000   // Send to all APICs, including self.
  #define BUSY       0x00001000
  #define FIXED      0x00000000
#define ICRHI   (0x0310/4)   // Interrupt Command [63:32]

/* 略 */

  lapicw(ICRHI, 0);
  lapicw(ICRLO, BCAST | INIT | LEVEL);
  while(lapic[ICRLO] &amp; DELIVS)
    ;
</code></pre>
<h2><a class="header" href="#tprの設定" id="tprの設定">TPRの設定</a></h2>
<p>lapicinit関数の最後に、TPR（Task Priority Register）に0を設定する。<br />
TPRについてはIntel-SDMの「Vol.3 10.8.3.1 Task and Processor Priorities」に記載されており、名前の通りタスク優先度の設定を行うことができる。</p>
<p>lapic.c</p>
<pre><code class="language-c">#define TPR     (0x0080/4)   // Task Priority

/* 略 */

  lapicw(TPR, 0);
</code></pre>
<h1><a class="header" href="#56-seginit関数" id="56-seginit関数">5.6. seginit関数</a></h1>
<p>この関数はGDTを作成し、ロードする。</p>
<p>ここまでは<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_03/03_01_bootasm.html">「3.1. bootasm.S」</a>で作成した3つのエントリを持つGDTを使用してきた。<br />
ここではユーザ空間用のセグメントディスクリプタを持った新しいGDTを作成する。</p>
<p>セグメントディスクリプタの構造は<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」（リンク8）</a>の「Vol.3 3.4.5 Segment Descriptors」に書いてある。</p>
<p>関数を実行しているcpu構造体のgdtフィールドに以下の4つのセグメントディスクリプタを作成する。0番目はNULLディスクリプタなので初期化は不要。</p>
<p>  1番目: カーネル用のコードセグメントディスクリプタ<br />
  2番目: カーネル用のデータセグメントディスクリプタ<br />
  3番目: ユーザ用のコードセグメントディスクリプタ<br />
  4番目: ユーザ用のデータセグメントディスクリプタ</p>
<p>4つともベースアドレスは0x0、セグメントリミットは0xFFFFF。<br />
Gフラグが1なので、セグメントリミットはページサイズ倍（4kB)され0xFFFFF000（4GB）となる。<br />
タイプは4つとも読み書き可能、コードセグメントディスクリプタのみ実行可能にもなっている。<br />
DPL（Descriptor Privilege Level）はカーネル用は0、ユーザ用は3。</p>
<p>全てのセグメントの範囲が0から4GBまでで重なっている。
メモリ管理にはページング機構を使用するが、セグメント機構は無効化できないため、こうして4GBまでをセグメント機構的になんにでも使えるようにしている。<br />
cpu構造体のgdtフィールドは要素数が6（定数NSEGS）に定義されているため、GDTにはエントリが6つあることになる。
0から4番目まではここで作成するが、5番目はプロセスのコンテキストスイッチを行う際にTSS（タスク状態セグメント）ディスクリプタとして作成することになる。</p>
<p>作成したGDTをlgdt関数でgdtレジスタにロードする。<br />
このとき、ecsレジスタの値は更新不要。
<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_03/03_01_bootasm.html#%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%83%88%E3%83%A2%E3%83%BC%E3%83%89%E3%81%B8%E3%81%AE%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88">「3.1. bootasm.S」</a>ではファージャンプを行うことでecsの設定を行っているが、コードセグメントディスクリプタのインデックスがここで作成したGDTでも変わらず1番目（8バイト目）であるため、再設定が不要。</p>
<p>mmu.h</p>
<pre><code class="language-c">#define SEG_KCODE 1  // kernel code
#define SEG_KDATA 2  // kernel data+stack
#define SEG_UCODE 3  // user code
#define SEG_UDATA 4  // user data+stack
#define SEG_TSS   5  // this process's task state

/* 略 */

#define SEG(type, base, lim, dpl) (struct segdesc)    \
{ ((lim) &gt;&gt; 12) &amp; 0xffff, (uint)(base) &amp; 0xffff,      \
  ((uint)(base) &gt;&gt; 16) &amp; 0xff, type, 1, dpl, 1,       \
  (uint)(lim) &gt;&gt; 28, 0, 0, 1, 1, (uint)(base) &gt;&gt; 24 }

/* 略 */

#define STA_X       0x8     // Executable segment
#define STA_W       0x2     // Writeable (non-executable segments)
#define STA_R       0x2     // Readable (executable segments)
</code></pre>
<p>vm.c</p>
<pre><code class="language-c">void
seginit(void)
{
  struct cpu *c;

  // Map &quot;logical&quot; addresses to virtual addresses using identity map.
  // Cannot share a CODE descriptor for both kernel and user
  // because it would have to have DPL_USR, but the CPU forbids
  // an interrupt from CPL=0 to DPL=3.
  c = &amp;cpus[cpuid()];
  c-&gt;gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
  c-&gt;gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
  c-&gt;gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
  c-&gt;gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
  lgdt(c-&gt;gdt, sizeof(c-&gt;gdt));
}
</code></pre>
<p>作成されたセグメントディスクリプタをgdbで確認すると以下のようになっている。</p>
<pre><code>$1 = {lim_15_0 = 0x0, base_15_0 = 0x0, base_23_16 = 0x0, type = 0x0, s = 0x0, dpl = 0x0, p = 0x0, lim_19_16 = 0x0, avl = 0x0, rsv1 = 0x0, db = 0x0, g = 0x0, base_31_24 = 0x0}
$2 = {lim_15_0 = 0xffff, base_15_0 = 0x0, base_23_16 = 0x0, type = 0xa, s = 0x1, dpl = 0x0, p = 0x1, lim_19_16 = 0xf, avl = 0x0, rsv1 = 0x0, db = 0x1, g = 0x1, base_31_24 = 0x0}
$3 = {lim_15_0 = 0xffff, base_15_0 = 0x0, base_23_16 = 0x0, type = 0x2, s = 0x1, dpl = 0x0, p = 0x1, lim_19_16 = 0xf, avl = 0x0, rsv1 = 0x0, db = 0x1, g = 0x1, base_31_24 = 0x0}
$4 = {lim_15_0 = 0xffff, base_15_0 = 0x0, base_23_16 = 0x0, type = 0xa, s = 0x1, dpl = 0x3, p = 0x1, lim_19_16 = 0xf, avl = 0x0, rsv1 = 0x0, db = 0x1, g = 0x1, base_31_24 = 0x0}
$5 = {lim_15_0 = 0xffff, base_15_0 = 0x0, base_23_16 = 0x0, type = 0x2, s = 0x1, dpl = 0x3, p = 0x1, lim_19_16 = 0xf, avl = 0x0, rsv1 = 0x0, db = 0x1, g = 0x1, base_31_24 = 0x0}
</code></pre>
<h2><a class="header" href="#cpuid関数" id="cpuid関数">cpuid関数</a></h2>
<p>この関数は、この関数を実行しているプロセッサのcpuidを返す。</p>
<p>ここで言うcpuidとは、cpus配列のインデックスのこと。<br />
各プロセッサのcpu構造体はcpus配列のエントリとして保持しており、mycpu関数はそれを実行しているプロセッサのエントリを返してくれる。<br />
そのエントリのアドレスからcpus配列の先頭アドレスを引けば、cpus配列内でのインデックスになる。</p>
<p>proc.c</p>
<pre><code class="language-c">&gt; 30 int
&gt; 31 cpuid() {
&gt; 32   return mycpu()-cpus;
&gt; 33 }
</code></pre>
<h2><a class="header" href="#mycpu関数" id="mycpu関数">mycpu関数</a></h2>
<p>この関数は、この関数を実行しているプロセッサのcpu構造体をcpus配列から探して返す。</p>
<p>eflagsレジスタの値を取得し、Interrupt enableビット（9bit）を確認して、割り込みが無効になっていることを確認する。
0が無効で1が有効。
eflagsレジスタの各bitの役割は<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」（リンク8）</a>の「Vol.3 2.3 SYSTEM FLAGS AND FIELDS IN THE EFLAGS REGISTER」に書いてある。</p>
<p>cpus配列をfor文で走査し、apicidフィールドの値が関数を実行しているプロセッサのLAPIC IDと等しいエントリを探す。
各cpu構造体のapicidフィールドは<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_04_mpinit.html">「5.4. mpinit関数」</a>で設定済み。</p>
<p>mmu.h</p>
<pre><code class="language-c">#define FL_IF           0x00000200      // Interrupt Enable
</code></pre>
<p>proc.c</p>
<pre><code class="language-c">struct cpu*
mycpu(void)
{
  int apicid, i;
  
  if(readeflags()&amp;FL_IF)
    panic(&quot;mycpu called with interrupts enabled\n&quot;);
  
  apicid = lapicid();
  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
  // a reverse map, or reserve a register to store &amp;cpus[i].
  for (i = 0; i &lt; ncpu; ++i) {
    if (cpus[i].apicid == apicid)
      return &amp;cpus[i];
  }
  panic(&quot;unknown apicid\n&quot;);
}
</code></pre>
<h2><a class="header" href="#readeflags関数" id="readeflags関数">readeflags関数</a></h2>
<p>この関数はeflagsレジスタの値を取得する。<br />
pushfl命令はeflagsレジスタの内容をスタックに積む命令。</p>
<p>x86.h</p>
<pre><code class="language-c">static inline uint
readeflags(void)
{
  uint eflags;
  asm volatile(&quot;pushfl; popl %0&quot; : &quot;=r&quot; (eflags));
  return eflags;
}
</code></pre>
<h2><a class="header" href="#lapic関数" id="lapic関数">lapic関数</a></h2>
<p>この関数は、この関数を実行しているプロセッサのLAPIC IDを取得する。</p>
<p>LAPIC IDは <a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」（リンク8）</a>の「Vol.3 10.4.6 Local APIC ID」によると、Local APIC ID Register（0x20）の24～31bitから得られる。<br />
LAPICへのアクセスについては<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_04_mpinit.html">「5.4. mpinit関数」</a>に書いた。</p>
<p>lapic.c</p>
<pre><code class="language-c">int
lapicid(void)
{
  if (!lapic)
    return 0;
  return lapic[ID] &gt;&gt; 24;
}
</code></pre>
<h1><a class="header" href="#57-picinit関数" id="57-picinit関数">5.7. picinit関数</a></h1>
<p>この関数はMPに対応していない古いPICでの割り込みを無効化する。</p>
<p>outb関数でポート0x20と0xA1に0xFFを書き込んでいる。
<a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html">「OSDev I/O Ports」（リンク10）</a>によると、ポート0x21はThe first Programmable Interrupt Controllerで、ポート0xA1はThe second PIC。
<a href="https://wiki.osdev.org/PIC">「OSDev 8259 PIC」（リンク16）</a>の「Disabling」によると、LAPICとIOAPICを使用する場合はPICを無効化しなければいならず、その方法として0xFFを設定する。</p>
<p>picirq.c</p>
<pre><code class="language-c">#define IO_PIC1         0x20    // Master (IRQs 0-7)
#define IO_PIC2         0xA0    // Slave (IRQs 8-15)

// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
void
picinit(void)
{
  // mask all interrupts
  outb(IO_PIC1+1, 0xFF);
  outb(IO_PIC2+1, 0xFF);
}
</code></pre>
<h1><a class="header" href="#58-ioapicinit関数" id="58-ioapicinit関数">5.8. ioapicinit関数</a></h1>
<p>この関数は、大域変数ioapicにIOAPICへのアクセスアドレスを設定し、IOリダイレクションテーブルの設定を行う。<br />
IRQ0～23番が、BSPにIRQ32～55番でリダイレクトされるよう設定を行い、それら全てを無効化する。</p>
<p><a href="https://wiki.osdev.org/IOAPIC">「OSDev IOAPIC」（リンク17）</a>のexternal linksからIOAPICの仕様書<a href="http://web.archive.org/web/20161130153145/http://download.intel.com/design/chipsets/datashts/29056601.pdf">「82093AA I/O ADVANCED PROGRAMMABLE INTERRUPT CONTROLLER (IOAPIC)」（リンク18）</a>が確認できる。<br />
仕様書の「3.0. REGISTER DESCRIPTION」によると、IOAPICの操作はI/O Register Selectレジスタにアクセスしたいレジスタのオフセットを書き込み、I/O Windowレジスタを通してデータの読み書きを行う。
I/O Register Selectレジスタのアドレスはデフォルトで0xFEC00000だが、制限された範囲内で変更が可能。xv6ではデフォルトのまま使用する。<br />
I/O Windowsレジスタのアドレスもデフォルトの0xFEC00010になる。<br />
xv6ではこの2つのレジスタにアクセスするため、ioapic構造体を定義している。
2つのアドレスは16バイト離れているため、padフィールドを設けている。
レジスタへの読み書きはioapicread関数とioapicwrite関数で行う。</p>
<p>ioapic.c</p>
<pre><code class="language-c">#define IOAPIC  0xFEC00000   // Default physical address of IO APIC

/* 略 */

volatile struct ioapic *ioapic;

// IO APIC MMIO structure: write reg, then read or write data.
struct ioapic {
  uint reg;
  uint pad[3];
  uint data;
};

static uint
ioapicread(int reg)
{
  ioapic-&gt;reg = reg;
  return ioapic-&gt;data;
}

static void
ioapicwrite(int reg, uint data)
{
  ioapic-&gt;reg = reg;
  ioapic-&gt;data = data;
}
</code></pre>
<p>仕様書の「Table 2. IOAPIC Registers」より、アクセスできるIOAPICのレジスタとオフセットは以下の通り。</p>
<ul>
<li>IOAPIC ID（オフセット0x00）</li>
<li>IOAPIC Version（0x01）</li>
<li>IOAPIC Arbitration ID（0x02）</li>
<li>Redirection Table（0x10～0x3F）</li>
</ul>
<p>IOリダイレクションテーブルを使用することで、外部割込みソースからの割込みをそのIRQ番号に応じてLAPICにリダイレクトすることができる。
テーブルのインデックスが入力されるIRQ番号に対応しており、各エントリにリダイレクト先LAPICやIRQ番号等を設定する。<br />
IOAPICへ入力されるIRQ番号がそれぞれどの割込みソースに割り当てられているのかは、そのデバイスが接続されているIOAPICのピンに依存する。
しかし、一般的に使用されるIRQ番号は決まっており、仕様書の「2.4. Interrupt Signals」の記載のほか、<a href="https://wiki.osdev.org/Interrupts">「OSDev Interrupt」（リンク29）</a>の「General IBM-PC Compativle Interrupt Information」にもリストされている。
これらによると、例えばIRQ0はProgrammable Interrupt Timer Interruptに、IRQ1はKeyboard Interruptに使用されることがわかる。<br />
エントリのサイズは64bitで、上下32bitずつオフセットを変えてアクセスすることになる。
仕様書の表2によるとテーブルのオフセット範囲は0x10～0x3Fであるため、エントリ数は24だが、IOAPIC VersionレジスタのMaximum Redirection Entryフィールド（16～23bit）から最大エントリ番号を得ることができる。
記載によると、最大で240エントリ持つことができる。</p>
<p>ioapicinit関数では、まず大域変数ioapicにIOAPICへのアクセスアドレス0xFEC00000を設定する。<br />
次にIOリダイレクションテーブルの最大エントリ番号と、IOAPIC IDを取得する。
デバッガで最大エントリ番号を見ると、今回は仕様書の値と同じ24（値は23）だった。
IOAPIC IDが<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_04_mpinit.html">「5.4. mpinit関数」</a>にてMP設定テーブルから取得したIOAPIC IDと異なる場合、コンソールにメッセージを出力する。
出力に使用するcprintf関数は<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_19_startothers.html#cprintf%E9%96%A2%E6%95%B0">「5.17 startothers関数」</a>で見る。</p>
<p>for文でIOリダイレクションテーブルのエントリを走査し、以下の設定を行う。
エントリの構造は仕様書の「3.2.4. IOREDTBL[23:0]—I/O REDIRECTION TABLE REGISTERS」に記載されている。</p>
<ul>
<li>Interrupt Mask（16bit）に1をセットしエントリを無効化</li>
<li>Interrupt Vector（0～7bit）にリダイレクト先IRQ番号としてタイマー割込み32番（T_IRQ0）から順にセット</li>
<li>Destination Mode（11bit）を0にしてPhysical Modeをセット</li>
<li>Destination Field（56～63bit）に0をセット。このフィールドはDestination Modeによって意味が異なり、Physical Modeではリダイレクト先のLAPIC IDを意味する。0なのでBSPにリダイレクトする。</li>
</ul>
<p>ioapic.c</p>
<pre><code class="language-c">#define REG_ID     0x00  // Register index: ID
#define REG_VER    0x01  // Register index: version
#define REG_TABLE  0x10  // Redirection table base

/* 略 */

#define INT_DISABLED   0x00010000  // Interrupt disabled

/* 略 */

void
ioapicinit(void)
{
  int i, id, maxintr;

  ioapic = (volatile struct ioapic*)IOAPIC;
  maxintr = (ioapicread(REG_VER) &gt;&gt; 16) &amp; 0xFF;
  id = ioapicread(REG_ID) &gt;&gt; 24;
  if(id != ioapicid)
    cprintf(&quot;ioapicinit: id isn't equal to ioapicid; not a MP\n&quot;);

  // Mark all interrupts edge-triggered, active high, disabled,
  // and not routed to any CPUs.
  for(i = 0; i &lt;= maxintr; i++){
    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
    ioapicwrite(REG_TABLE+2*i+1, 0);
  }
}
</code></pre>
<p>このIOリダイレクションテーブルの設定により、IRQ0～23番がBSPのLAPICにIRQ32～55番でリダイレクトされるが、この時点では全てのリダイレクトが無効化された状態になっている。<br />
エントリの有効化は、後ほどioapicenable関数を呼び出して個別に行う。その際に割込み先LAPIC IDも再設定する。</p>
<h1><a class="header" href="#59-consoleinit関数" id="59-consoleinit関数">5.9. consoleinit関数</a></h1>
<p>この関数はdevsw配列の1番にコンソール読み書き用の関数を設定し、IOAPICのキーボードコントローラからの割込みのリダイレクト（IRQ1からIRQ33へのリダイレクト）を有効化する。</p>
<p>デバイスの読み書きにはdevsw構造体を使用する。
この構造体は関数ポインタreadとwriteを持っており、そこにデバイス毎の読み書き用の関数を持っておく。<br />
file.cでdevsw構造体の配列devswが定義されており、デバイス10個分の構造体を持つことができる。
この配列の1番目をコンソールのために使用する。残りの9個は使用しない。
ディスクの読み書きにはdevsw構造体を使用せず、ide.cに定義されているiderw関数を使用する。</p>
<p>file.h</p>
<pre><code class="language-c">struct devsw {
  int (*read)(struct inode*, char*, int);
  int (*write)(struct inode*, char*, int);
};
</code></pre>
<p>file.c</p>
<pre><code class="language-c">struct devsw devsw[NDEV];
</code></pre>
<p>param.h</p>
<pre><code class="language-c">#define NDEV         10  // maximum major device number
</code></pre>
<p>コンソールの排他制御にはconsole.cの静的変数consを使用する。
consはspinlock構造体のlockフィールドと、int型のlockingフィールドを持っている。
lockフィールドはコンソールを使用する際のロックに使われる。
ロックについては<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_10_lock.html">「5.10. ロック（spinlock, sleeplock）」</a>に書く。
lockingフィールドの値は通常1で、panic関数が呼ばれると0になり、その後1に戻ることはない。
このフィールドはcprintf関数内で使用されており、値が1の場合はコンソールのロックを取り、0の場合は取らない。
おそらくpanic関数が呼ばれた際に、既にコンソールのロックが取られている可能性があるため、panic関数でlockingを0にするのだと思う。</p>
<p>console.c</p>
<pre><code class="language-c">static struct {
  struct spinlock lock;
  int locking;
} cons;
</code></pre>
<p>consoleinit関数ではまずconsのlockフィールドを初期化する。<br />
devsw配列のコンソール（1番）のwriteフィールドにconsolewrite関数を設定し、readフィールドにconsoleread関数を設定する。<br />
次にconsのlockingフィールドを1で初期化する。
この値は上述したように、panicが呼ばれるまで0にならない。<br />
最後に、ioapicenable関数でキーボードコントローラからの割込みを有効化する。</p>
<p>file.h</p>
<pre><code class="language-c">#define CONSOLE 1
</code></pre>
<p>traps.h</p>
<pre><code class="language-c">#define IRQ_KBD          1
</code></pre>
<p>console.c</p>
<pre><code class="language-c">void
consoleinit(void)
{
  initlock(&amp;cons.lock, &quot;console&quot;);

  devsw[CONSOLE].write = consolewrite;
  devsw[CONSOLE].read = consoleread;
  cons.locking = 1;

  ioapicenable(IRQ_KBD, 0);
}
</code></pre>
<h2><a class="header" href="#consolewrite関数" id="consolewrite関数">consolewrite関数</a></h2>
<p>この関数はコンソールに文字を出力する。</p>
<p>inodeのロックを解放し、コンソールのロックを取ってbufからn文字分出力する。
出力が終わったらコンソールのロックを解放し、inodeのロックを再び取得する。
コンソール出力中はinodeのロックが不要なのでロックを解放する。
inodeについては<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_11_ilock.html">「5.11. iノードのロック」</a>に書く。<br />
出力はconsputc関数で行う。
consputc関数の引数はint型だが、アスキーコードの範囲で渡したいので、0xffで論理積を取って1バイトだけ渡す。</p>
<p>console.c</p>
<pre><code class="language-c">int
consolewrite(struct inode *ip, char *buf, int n)
{
  int i;

  iunlock(ip);
  acquire(&amp;cons.lock);
  for(i = 0; i &lt; n; i++)
    consputc(buf[i] &amp; 0xff);
  release(&amp;cons.lock);
  ilock(ip);

  return n;
}
</code></pre>
<p>consputc関数はシリアルポートが有ればそちらに書き込みを行い、無ければメモリにマップされているビデオメモリに書き込む。
シリアルポートへの書き込みはuartputc関数で行い、ビデオメモリへの書き込みはcgaputc関数で行う。
シリアルポートの有無はmain関数から呼ばれるuartinit関数で確認する。
また、シリアルポートにバックスペースを書き込む際には、'\b'でカーソル位置を1文字戻し、空白を印字し、再びカーソル位置を1文字戻す。<br />
console.cにはint型の静的変数panickedが定義されており、この値はpanic関数が呼ばれると1になる。
consputc関数は、panic関数が呼ばれている場合は、割り込みを無効化し、無限ループする。</p>
<p>console.c</p>
<pre><code class="language-c">static int panicked = 0;

/* 略 */

void
consputc(int c)
{
  if(panicked){
    cli();
    for(;;)
      ;
  }

  if(c == BACKSPACE){
    uartputc('\b'); uartputc(' '); uartputc('\b');
  } else
    uartputc(c);
  cgaputc(c);
}
</code></pre>
<p>uartputc関数は<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_13_uartinit.html">「5.13. uartinit」</a>に書くとして、cgaputc関数を見る。
cgaputc関数はメモリ上のビデオメモリ領域に書き込むことで画面出力を行う。</p>
<p>カーソル位置はCRTコントローラを使用して読み書きする。
<a href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/crtcreg.htm">「Hardware Level VGA and SVGA Video Programming Information Page CRT Controller Registers」（リンク19）</a>
によると、CRTCレジスタにはアドレスレジスタとデータレジスタがあり、それぞれポート0x3d4とポート0x3d5からアクセスできる。
リンク先の「Cursor Location High Register (Index 0Eh)」と「Cursor Location Low Register (Index 0Fh)」に、アドレスレジスタに14（0xE）と15（0xF）を書き込むことで、データレジスタからカーソル位置を取得することができると記載がある。
カーソル位置は画面左上を0として、1行80文字、25行までで連続して増加していく。</p>
<p>プロテクトモード時のビデオモードに関しては<a href="https://wiki.osdev.org/Drawing_In_Protected_Mode">「OSDev Drawing In Protected Mode」（リンク20）</a>に記載されており、ここではCGAモードなので物理アドレス0xb8000からビデオメモリ領域になっている。<br />
ビデオメモリへは2バイトずつ書き込みを行い、書き込む値は<a href="https://wiki.osdev.org/Text_UI">「OSDev Text UI」（リンク21）</a>によると、上位1バイトで色を指定し、下位1バイトでASCIIコードを指定する。
色の指定方法はリンク先の「Colours」で図解されており、上位4bitで背景色、下位4bitで文字色を指定する。
また、3, 7bit目がそれぞれbright bitとなっており、立てると明るい色になる。
cgaputc関数では0x0700で論理和を取り文字色をライトグレイにしているが、例えば0xb200で論理和を取ると背景色がライトシアンとなり、文字色が緑色となる。</p>
<p>cgaputc関数ではint型の変数posでカーソル位置を操作する。<br />
引数が改行コードの場合、posが次の行の先頭になるように、80 - 現在位置%80だけ加算する。<br />
引数がバックスペースかつposが0より大きい場合、posをデクリメントする。<br />
それ以外の場合は現在位置の次の位置に引数の文字（1バイト）を文字色ライトグレイ、背景色黒で描画する。<br />
変数crtはメモリ上のビデオメモリ領域の開始アドレス（0xb8000）を持っている。<br />
カーソル位置が0未満或いは25行80列より大きいところを指している場合、panicする。<br />
25行目を指している場合、memmove関数を使用して全体を1行分前方に動かし、カーソル位置も1行分減らす。
全体を1行分前にコピーするので、最終行に値が残っている。それをmemset関数で0にリセットする。<br />
最後に画面上の現在の位置にスペースを書き込む。</p>
<p>console.c</p>
<pre><code class="language-c">#define BACKSPACE 0x100
#define CRTPORT 0x3d4
static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory

static void
cgaputc(int c)
{
  int pos;

  // Cursor position: col + 80*row.
  outb(CRTPORT, 14);
  pos = inb(CRTPORT+1) &lt;&lt; 8;
  outb(CRTPORT, 15);
  pos |= inb(CRTPORT+1);

  if(c == '\n')
    pos += 80 - pos%80;
  else if(c == BACKSPACE){
    if(pos &gt; 0) --pos;
  } else
    crt[pos++] = (c&amp;0xff) | 0x0700;  // black on white

  if(pos &lt; 0 || pos &gt; 25*80)
    panic(&quot;pos under/overflow&quot;);

  if((pos/80) &gt;= 24){  // Scroll up.
    memmove(crt, crt+80, sizeof(crt[0])*23*80);
    pos -= 80;
    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
  }

  outb(CRTPORT, 14);
  outb(CRTPORT+1, pos&gt;&gt;8);
  outb(CRTPORT, 15);
  outb(CRTPORT+1, pos);
  crt[pos] = ' ' | 0x0700;
}
</code></pre>
<h2><a class="header" href="#memmove関数" id="memmove関数">memmove関数</a></h2>
<p>この関数は第二引数のアドレス（ソース）から第三引数のサイズ分、第一引数のアドレス（移動先）にコピーする。
このとき、ソースが移動先より手前で開始し、移動先がコピーサイズ分に被るとき、頭からコピーしていくとソースの一部が上書きされ失われるので、末尾からコピーしていく。</p>
<p>string.c</p>
<pre><code class="language-c">void*
memmove(void *dst, const void *src, uint n)
{
  const char *s;
  char *d;

  s = src;
  d = dst;
  if(s &lt; d &amp;&amp; s + n &gt; d){
    s += n;
    d += n;
    while(n-- &gt; 0)
      *--d = *--s;
  } else
    while(n-- &gt; 0)
      *d++ = *s++;

  return dst;
}
</code></pre>
<h2><a class="header" href="#consoleread関数" id="consoleread関数">consoleread関数</a></h2>
<p>この関数はコンソールからnバイト読み込む。</p>
<p>コンソールへの入力に起因する割り込みから順に書くことにする。
なお、割り込み時の動作については<a href="chapter_05/">「」</a>に書く。<br />
キーボードあるいはシリアルポートから入力が行われると、割込みが生じ最終的にkbdintr関数かuartintr関数が呼ばれる。
それらはいずれもconsoleintr関数を呼び出しており、引数としてkbdgetc関数あるいはuartgetc関数を渡す。
uartgetc関数については<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_13_uartinit.html">「5.13. uartinit関数」</a>に書く。</p>
<p>kbd.c</p>
<pre><code class="language-c">void
kbdintr(void)
{
  consoleintr(kbdgetc);
}
</code></pre>
<p>uart.c</p>
<pre><code class="language-c">void
uartintr(void)
{
  consoleintr(uartgetc);
}
</code></pre>
<h3><a class="header" href="#kbdgetc関数" id="kbdgetc関数">kbdgetc関数</a></h3>
<p>この関数はキーボードコントローラからの入力信号（スキャンコード）を解析し、キーボードに入力された文字コードを返す。<br />
<a href="http://bochs.sourceforge.net/doc/docbook/development/index.html">「Bochs Developers Guide」（リンク9）</a>によると、ポート0x60（アウトプットバッファ）から、スキャンコードを取得できる。
スキャンコードに関しては<a href="https://www.win.tue.nl/%7Eaeb/linux/kbd/scancodes.html">「Keyboard scancodes Andries Brouwer」（リンク7）</a>で解説されており、キーが押されるときmakeコードが入力され、離されるときにbreakコードが入力される。
breakコードはmakeコードに0x80が加算された値になっている。
例えば、aキーが押されると0x1eが入力され、キーが離されて0x9eが入力される。
また、コード0xe0と0xe1はエスケープシーケンスになっており、プリフィクスとして使用される。
あるキーを押すと、0xe0が入力され、続けて入力される特定のスキャンコードと共に解釈することになる。
例えば、方向キー上が押されると0xe0が入力され、続けて0x48が入力され、離された後に0xc8が入力される。
なので、gdbで確認する際はキーが押されたときと、離されたときを別々に観測するとよい。</p>
<p>xv6では、スキャンコードから文字コードへの変換にkbd.hに定義されている3つの配列normalmap、shiftmap、ctlmapを使用する。<br />
各配列は名前の通り、普通の入力、シフトキーを使用した入力、コントロールキーを使用した入力で使用される。
参照する配列の切り替えには、shiftcodeとtogglecodeの2つの配列を使用する。
そこにはCTRLキーやALTキー、CAPSLOCKキー等が定義されている。<br />
kbdget関数では配列charcodeに変換に使用する3つの配列を持っておく。
4番目のctlmapはシフトキーとコントロールキーが同時に入力された場合に使用される。</p>
<p>ctlmap配列ではCマクロが使用されており、このマクロは与えられた文字コードを制御コードに変換する。
各制御コードは<a href="https://www.ascii-code.com/">「ASCII Code - The extended ASCII table」（リンク27）</a>で確認できる。
例えば<code>C('C')</code>の場合、
<code>'C' - '@' = 0x43 - 0x40 = 0x03</code>
なので、End of Text（0x03）となる。</p>
<p>kbd.h</p>
<pre><code class="language-c">// C('A') == Control-A
#define C(x) (x - '@')
</code></pre>
<p>エスケープシーケンス（0xe0）や、シフトキー、コントロールキー、CAPSLOCKのオンオフは変数shiftの各bitで表現する。
各bitの役割は以下。</p>
<p>kbd.h</p>
<pre><code class="language-c">&gt;  9 #define SHIFT           (1&lt;&lt;0)
&gt; 10 #define CTL             (1&lt;&lt;1)
&gt; 11 #define ALT             (1&lt;&lt;2)
&gt; 12 
&gt; 13 #define CAPSLOCK        (1&lt;&lt;3)
&gt; 14 #define NUMLOCK         (1&lt;&lt;4)
&gt; 15 #define SCROLLLOCK      (1&lt;&lt;5)
&gt; 16 
&gt; 17 #define E0ESC           (1&lt;&lt;6)
</code></pre>
<p>変数shiftのSHIFTビットもCTLビットも設定されていれば4エントリ目のctlmapテーブルが使用される。</p>
<p>kbdgetc関数ははじめに、キーボードコントローラのステータス（0x64）を取得する。
ステータスの0bitからインプットバッファの状態を確認でき、1のときフル、0のとき空を示す。<br />
アウトプットバッファ（0x60）から1つ分のスキャンコードを取得し、次のように分岐する。</p>
<ul>
<li>エスケープシーケンス（0xE0）の場合、変数shiftのE0ESCビットを立てる。</li>
<li>breakコードの場合、つまりキーが離された場合、変数shiftのE0ESCビット、SHIFTビット、CTLビット、ALTビットを0にする。
CAPSLOCKビットやNUMLOCKビット、SCROLLLOCKビットは入力を跨いで有効となるため変更しない。
エスケープシーケンス以外の場合、0x7fとの論理積によりmakeコードを取得している。</li>
<li>変数shiftのE0ESCビットが1の場合、変数dataにbreakコード（0x80を論理和）を代入し、E0ESCビットを0にする。エスケープシーケンス（0xE0）が使用される場合breakコードが入力されないので、続くスキャンコードをbreakコードに変換する必要がある。</li>
</ul>
<p>次に、スキャンコードの変換に用いる配列を決定するため、変数shiftを設定する。
shiftcode配列はそのままビットを設定するが、togglecode配列はCAPSLOCKやNUMLOCK等を扱うため排他的論理和でビットを更新する。<br />
最後に配列から文字コードを取得するが、変数shiftのCAPSLOCKビットが1の場合、アルファベットの大文字と小文字を変換する。</p>
<p>kbd.c</p>
<pre><code class="language-c">int
kbdgetc(void)
{
  static uint shift;
  static uchar *charcode[4] = {
    normalmap, shiftmap, ctlmap, ctlmap
  };
  uint st, data, c;

  st = inb(KBSTATP);
  if((st &amp; KBS_DIB) == 0)
    return -1;
  data = inb(KBDATAP);

  if(data == 0xE0){
    shift |= E0ESC;
    return 0;
  } else if(data &amp; 0x80){
    // Key released
    data = (shift &amp; E0ESC ? data : data &amp; 0x7F);
    shift &amp;= ~(shiftcode[data] | E0ESC);
    return 0;
  } else if(shift &amp; E0ESC){
    // Last character was an E0 escape; or with 0x80
    data |= 0x80;
    shift &amp;= ~E0ESC;
  }

  shift |= shiftcode[data];
  shift ^= togglecode[data];
  c = charcode[shift &amp; (CTL | SHIFT)][data];
  if(shift &amp; CAPSLOCK){
    if('a' &lt;= c &amp;&amp; c &lt;= 'z')
      c += 'A' - 'a';
    else if('A' &lt;= c &amp;&amp; c &lt;= 'Z')
      c += 'a' - 'A';
  }
  return c;
}
</code></pre>
<h3><a class="header" href="#consoleintr関数" id="consoleintr関数">consoleintr関数</a></h3>
<p>この関数はキーボードやシリアルポートから入力された値を読み取り、それをコンソールに出力する。
また、入力を待っているプロセスを起床させ、値を渡す。</p>
<p>入力を待っているプロセスはconsoleread関数でスリープしており、input構造体を通して値を渡す。<br />
input構造体は次の4つのフィールドで構成される。</p>
<ul>
<li>buf: 入力された直近128文字を持つ</li>
<li>r: bufフィールドからプロセスが読み出した位置を示すとともに、コンソールへの出力を待っているプロセスを起床させるチャネルとしても使用される。</li>
<li>w: bufフィールドからコンソールに出力した位置を示す</li>
<li>e: bufフィールドの現在位置を表す</li>
</ul>
<p>bufは要素127まで来たら要素0から上書きするため、読み書きする際は要素数で割った余りをインデックスとして使用する。
r、w、eの各フィールドは0から開始する。
文字が入力される度にeがインクリメントされbufに文字が入る。
それをコンソールに出力するとwがeで更新され、追いつく。
コンソールへの文字出力後、consoleread関数でスリープしているプロセスが起床され、そこでrからwの位置までbufの中身を読み取る。
r、w、eは明示的に初期化されることはなく、uintの最大値2の32乗-1まで増加し続ける。</p>
<p>console.c</p>
<pre><code class="language-c">#define INPUT_BUF 128
struct {
  char buf[INPUT_BUF];
  uint r;  // Read index
  uint w;  // Write index
  uint e;  // Edit index
} input;
</code></pre>
<p>while文で1文字ずつ読み、switch文で次のように分岐する。</p>
<ul>
<li>Ctrl + Pの場合、procdump関数を実行する。この関数はプロセスの一覧を出力し、スリープ状態のプロセスの場合はコールスタックも出力する。</li>
<li>Ctrl + Uの場合、コンソールの現在の行の文字を全て消す。
現在位置eを行頭まで戻しつつ、文字を1文字ずつ消していく。</li>
<li>Ctrl + H、あるいはバックスペース（0x7f）の場合、1文字消す。
バックスペースが入力されると、キーボードの場合はkbdgetc関数からバックスペース（0x08）が返ってきてCtrl + Hのケースに一致し、シリアルポートの場合はuartgetc関数からデリート（0x7f）が返ってきてこのケースに一致する。
コンソールの現在位置eと前回の最終出力位置wが等しくない場合、つまり消せる入力がある場合はeをデクリメントし、consputc関数を使ってバックスペースを出力する。</li>
<li>上記以外の場合、文字をコンソールに出力する。
キャリッジリターン（0x0d）は改行（0x0a）に変換する。</li>
</ul>
<p>次の場合、出力済み位置wに現在位置eを代入し、rのアドレスをチャネルとしてスリープしているプロセスを起床させる。</p>
<ul>
<li>入力が終了する（Enter）</li>
<li>Ctrl + Dが入力される（EOT）</li>
<li>読み込む必要がある文字列がbufの容量と等しくなった場合</li>
</ul>
<p>スリープしているプロセスはコンソールへ入力された文字列（bufの中身）を読み取り、解釈する。</p>
<p>console.c</p>
<pre><code class="language-c">void
consoleintr(int (*getc)(void))
{
  int c, doprocdump = 0;

  acquire(&amp;cons.lock);
  while((c = getc()) &gt;= 0){
    switch(c){
    case C('P'):  // Process listing.
      // procdump() locks cons.lock indirectly; invoke later
      doprocdump = 1;
      break;
    case C('U'):  // Kill line.
      while(input.e != input.w &amp;&amp;
            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
        input.e--;
        consputc(BACKSPACE);
      }
      break;
    case C('H'): case '\x7f':  // Backspace
      if(input.e != input.w){
        input.e--;
        consputc(BACKSPACE);
      }
      break;
    default:
      if(c != 0 &amp;&amp; input.e-input.r &lt; INPUT_BUF){
        c = (c == '\r') ? '\n' : c;
        input.buf[input.e++ % INPUT_BUF] = c;
        consputc(c);
        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
          input.w = input.e;
          wakeup(&amp;input.r);
        }
      }
      break;
    }
  }
  release(&amp;cons.lock);
  if(doprocdump) {
    procdump();  // now call procdump() wo. cons.lock held
  }
}
</code></pre>
<p>consoleread関数はinput構造体のbufフィールドを読み込む。<br />
コンソールの読み込み位置（r）が出力済み位置（w）に追いついている場合、入力待ちのために現在のプロセスをスリープ状態にする。
このため第一引数で与えられたiノードのロックを開放する。
スリープについては<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_10_lock.html">「5.10. ロック（spinlock, sleeplock）」</a>に書く。<br />
プロセスが起床し、出力済み位置（w）が読み込み位置（r）よりも先に進んだ場合、rをインクリメントしbufから文字コードを取り出す。
文字コードがCtrl + D（EOT）の場合、読み込みのwhileループから抜ける。
このとき、既に何文字か読み込んでいた場合はrをデクリメントする。
これにより、次回実行時にはwhileループに入らず、そのまま同じEOTを読み込むことになり、直ぐにbreakでループを抜けることになる。
呼び出し元にreturnで返される読み込んだ文字数は0になり、第二引数dstには何も書き込まれず、呼び出し元は読み込みたい文字列がEOTで終了されたことを知ることができる。</p>
<p>console.c</p>
<pre><code class="language-c">int
consoleread(struct inode *ip, char *dst, int n)
{
  uint target;
  int c;

  iunlock(ip);
  target = n;
  acquire(&amp;cons.lock);
  while(n &gt; 0){
    while(input.r == input.w){
      if(myproc()-&gt;killed){
        release(&amp;cons.lock);
        ilock(ip);
        return -1;
      }
      sleep(&amp;input.r, &amp;cons.lock);
    }
    c = input.buf[input.r++ % INPUT_BUF];
    if(c == C('D')){  // EOF
      if(n &lt; target){
        // Save ^D for next time, to make sure
        // caller gets a 0-byte result.
        input.r--;
      }
      break;
    }
    *dst++ = c;
    --n;
    if(c == '\n')
      break;
  }
  release(&amp;cons.lock);
  ilock(ip);

  return target - n;
}
</code></pre>
<h2><a class="header" href="#ioapicenable関数" id="ioapicenable関数">ioapicenable関数</a></h2>
<p>この関数は指定されたIRQのリダイレクトを有効化し、リダイレクト先LAPICを設定する。</p>
<p>IOリダイレクションテーブルの設定は<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_08_ioapicinit.html">「5.8. ioapicinit関数」</a>で行った。
ここではそこでも使用したioapicwrite関数にて、エントリのDestination Field（56bit（32+24））にLAPIC IDを設定する。
また、同時にInterrupt Mask（16bit）が0に設定されることにより割り込みのリダイレクトを有効化している。</p>
<p>ioapic.c</p>
<pre><code class="language-c">void
ioapicenable(int irq, int cpunum)
{
  // Mark interrupt edge-triggered, active high,
  // enabled, and routed to the given cpunum,
  // which happens to be that cpu's APIC ID.
  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
  ioapicwrite(REG_TABLE+2*irq+1, cpunum &lt;&lt; 24);
}
</code></pre>
<h1><a class="header" href="#510-ロックspinlock-sleeplock" id="510-ロックspinlock-sleeplock">5.10. ロック（spinlock, sleeplock）</a></h1>
<p><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">「xv6 a simple, Unix-like teaching operating system」（リンク1）</a>の4章「Locking」と5章「Scheduling」を読むとよい。
xv6には<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_10_lock.html#%E3%82%B9%E3%83%94%E3%83%B3%E3%83%AD%E3%83%83%E3%82%AF">スピンロック</a>と<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_10_lock.html#%E3%82%B9%E3%83%AA%E3%83%BC%E3%83%97%E3%83%AD%E3%83%83%E3%82%AF">スリープロック</a>の2種類のロックがあり、それぞれacquire関数とacquiresleep関数で取ることができる。
前者はロックが取れるまでプロセッサを占有するので短時間のロックに使用し、後者はロックが取れるまでプロセッサを明け渡すので長時間のロックに使用する。<br />
ロックの解放には<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_10_lock.html#release%E9%96%A2%E6%95%B0">release関数</a>と<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_10_lock.html#releasesleep%E9%96%A2%E6%95%B0">releasesleep関数</a>をそれぞれ使用する。</p>
<h2><a class="header" href="#スピンロック" id="スピンロック">スピンロック</a></h2>
<p>このロックはロックが取れるまでプロセッサを明け渡さない。<br />
spinlock構造体を使用する。
主に使用するのはlockedフィールドで、1のときロック済みであることを示す。
cpuフィールドやpcsフィールドはデバッグに使用する。</p>
<p>spinlock.h</p>
<pre><code class="language-c">struct spinlock {
  uint locked;       // Is the lock held?

  // For debugging:
  char *name;        // Name of lock.
  struct cpu *cpu;   // The cpu holding the lock.
  uint pcs[10];      // The call stack (an array of program counters)
                     // that locked the lock.
};
</code></pre>
<h2><a class="header" href="#acquire関数" id="acquire関数">acquire関数</a></h2>
<p>この関数は、割り込みを無効にし、他のプロセッサがロックを解放するまで待ってからロックを取得する。
ロック取得後にspinlock構造体に自分のcpu構造体と、最大10個分のコールスタックを記録する。</p>
<p>まず現在のプロセッサで割り込みを禁止する。
もしもここで割り込みを禁止しなかった場合、あるロックを取得し、直後に割り込みが生じて同じロックを取得しようとした場合に割り込み側がロックが解放されるまで待つことになるが、ロックを持っている処理は進まないのでデッドロックとなる。<br />
現在のプロセッサが既にそのロックを取得している場合はpanicする。<br />
spinlock構造体のlockedフィールドを1にできるまで（ロックを取得できるまで）ループする。
ここがスピンロックの肝であり、<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_10_lock.html#xchg%E9%96%A2%E6%95%B0">xchg関数</a>でlockedフィールドの独立性を保つ。<br />
ロック取得前後の命令の実行順序が入れ替わらないように__sync_synchronize関数を呼び出す。
この関数はGCCのビルトイン関数で、<a href="https://gcc.gnu.org/onlinedocs/gcc-6.5.0/gcc/">「Using the GNU Compiler Collection (GCC)」 （リンク3）</a>の「6.51 Legacy __sync Built-in Functions for Atomic Memory Access」によると、フルメモリバリアを行う関数である。
手元でコードを書きアセンブリ出力してみると、mfence命令にコンパイルされる。
mfence命令は、<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」（リンク8）</a>によると、この命令の前にあるメモリを読み書きする命令は必ずこの命令よりも前に実行され、この命令の後にあるメモリを読み書きする命令は必ずこの命令よりも後に実行されることを保証する。
これはプロセッサのOut-Of-Order実行を抑止するという点で、コンパイラレベルの最適化を抑止するvolatile修飾子とは異なる。
Out-Of-Order実行やプロセッサの仕組みについては<a href="chapter_05/ref_books.html">「プロセッサを支える技術」（書籍4）</a>がとても詳しくて分かりやすい。<br />
acquire関数は最後に、デバッグのための情報をspinlock構造体の中に残す。</p>
<p>spinlock.c</p>
<pre><code class="language-c">void
acquire(struct spinlock *lk)
{
  pushcli(); // disable interrupts to avoid deadlock.
  if(holding(lk))
    panic(&quot;acquire&quot;);

  // The xchg is atomic.
  while(xchg(&amp;lk-&gt;locked, 1) != 0)
    ;

  // Tell the C compiler and the processor to not move loads or stores
  // past this point, to ensure that the critical section's memory
  // references happen after the lock is acquired.
  __sync_synchronize();

  // Record info about lock acquisition for debugging.
  lk-&gt;cpu = mycpu();
  getcallerpcs(&amp;lk, lk-&gt;pcs);
}
</code></pre>
<h2><a class="header" href="#pushcli関数とpopcli関数" id="pushcli関数とpopcli関数">pushcli関数とpopcli関数</a></h2>
<p>割り込みの禁止は呼び出される関数によりネストされるので、これらの関数で管理する。</p>
<p>pushcli関数は現在のcpuの割り込みを禁止する。
この関数が実行される度にcpu構造体のncliフィールドがインクリメントされる。
関数呼び出し前に既に割り込み禁止としている場合があるため、ncliが0のときだけeflagsレジスタのInterrupt enableビット（9bit）を、cpu構造体のintenaフィールドに保存する。</p>
<p>popcli数はpushcli関数とは反対に、ncliフィールドをデクリメントする。
ncliフィールドとintenaフィールドに従って割り込みを有効化する。</p>
<p>spinlock.c</p>
<pre><code class="language-c">void
pushcli(void)
{
  int eflags;

  eflags = readeflags();
  cli();
  if(mycpu()-&gt;ncli == 0)
    mycpu()-&gt;intena = eflags &amp; FL_IF;
  mycpu()-&gt;ncli += 1;
}

void
popcli(void)
{
  if(readeflags()&amp;FL_IF)
    panic(&quot;popcli - interruptible&quot;);
  if(--mycpu()-&gt;ncli &lt; 0)
    panic(&quot;popcli&quot;);
  if(mycpu()-&gt;ncli == 0 &amp;&amp; mycpu()-&gt;intena)
    sti();
}
</code></pre>
<h2><a class="header" href="#holding関数" id="holding関数">holding関数</a></h2>
<p>この関数は引数のspinlock構造体のロックを現在のプロセッサが取っている場合に1を返す。</p>
<p>spinlock.c</p>
<pre><code class="language-c">int
holding(struct spinlock *lock)
{
  int r;
  pushcli();
  r = lock-&gt;locked &amp;&amp; lock-&gt;cpu == mycpu();
  popcli();
  return r;
}
</code></pre>
<h2><a class="header" href="#xchg関数" id="xchg関数">xchg関数</a></h2>
<p>この関数はaddrにnewvalを代入し、元々入っていた値を呼び出し元に返す。
このとき、必ず単一のプロセッサのみが値の代入に成功する。</p>
<p>lock接頭辞とxchgl命令により、単一のプロセッサのみが値を変更できることを保証している。
命令的には値を代入するというより、交換する。
<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」（リンク8）</a>によると、lock接頭辞は特定の命令あるいは出力がメモリである命令の場合に使用することができ、プロセッサのロッキングプロトコルを働かせることができる。
xchgl命令はlock接頭辞と組み合わせることが可能で、第一オペランドと第二オペランドの内容を交換する。</p>
<p>この関数の拡張インラインアセンブリの、入出力と破壊対象は次のようになっている。</p>
<p><strong>出力:</strong>
<code>&quot;+m&quot; (*addr)</code>
と
<code>&quot;=a&quot;(result)</code><br />
<strong>入力:</strong>
<code>&quot;1&quot;(newval)</code><br />
<strong>破壊対象:</strong>
<code>&quot;cc&quot;</code></p>
<p>使用されている各制約は<a href="https://gcc.gnu.org/onlinedocs/gcc-6.5.0/gcc/">「Using the GNU Compiler Collection (GCC)」（リンク3）</a>に記載されている。
<code>&quot;cc&quot;</code> は「6.44.2 Extended Asm - Assembler Instructions with C Expression Operands」に記載されており、他の制約は「6.44.3 Constraints for asm Operands」の各項に記載されている。<br />
出力について、
<code>&quot;+&quot;</code>
は読み書きに使用されることを示し、
<code>&quot;m&quot;</code>
はメモリのアドレスであることを示す。
また、
<code>&quot;=&quot;</code>
は書き込みのみに使用されることを示し、
<code>&quot;a&quot;</code>
は
x86ではeaxレジスタを示す。<br />
入力について、
<code>&quot;1&quot;</code>
は %1 と同じものを指すので、eaxとなる。<br />
破壊対象について、
<code>&quot;cc&quot;</code>
はフラグレジスタを示す。
しかし、Intel SDM（リンク8）のlock接頭辞とxchg命令のFlags AffectedにはどちらもNoneが記載されているため、なぜこれが必要なのかはわからない。</p>
<p>xchg関数の動きをまとめると、入力としてnewvalをeaxに入れ、<code>xchgl addr, %eax</code>となり、addrとeaxの中身が交換され、eaxにはaddrに元々入っていた値が入る。
出力としてeaxをresultと紐づけているので、resultにはaddrに元々入っていた値が入る。</p>
<p>acquire関数では、この関数からの戻り値をwhileループの条件に使用している。
戻り値が1の場合は他のプロセッサがロックを取っていることになり、0の場合は誰もロックを取っていないということになる。</p>
<p>x86.h</p>
<pre><code class="language-c">static inline uint
xchg(volatile uint *addr, uint newval)
{
  uint result;

  // The + in &quot;+m&quot; denotes a read-modify-write operand.
  asm volatile(&quot;lock; xchgl %0, %1&quot; :
               &quot;+m&quot; (*addr), &quot;=a&quot; (result) :
               &quot;1&quot; (newval) :
               &quot;cc&quot;);
  return result;
}
</code></pre>
<h2><a class="header" href="#getcallerpcs関数" id="getcallerpcs関数">getcallerpcs関数</a></h2>
<p>この関数は引数pcs配列にコールスタックを作成する。</p>
<p>動作は関数の呼び出し規約が分かると分かりやすい。
呼び出し規約については<a href="chapter_05/ref_books.html">「コンピュータの構成と設計 第4版」（書籍5）</a>に説明があり、GCCにおける呼び出し規約は<a href="http://www.delorie.com/djgpp/doc/ug/asm/calling.html">「Guide: Function Calling Conventions」（リンク22）</a>にまとめられている。<br />
この関数はまず変数ebpに現在のスタックフレームのベースアドレスを取得する。
スタックには引数pcs、引数v、リターンアドレス、ベースアドレスの順で積まれており、ひとつ16バイトで低いアドレスへ伸びていくので、引数vの積まれているアドレスから、-32バイトするとベースアドレスを得ることができる。<br />
次にspinlock構造体の配列pcsは要素数が10なので、10個分までのスタックフレームのベースアドレスを入れるため、for文で10回ループする。
ベースアドレスをpcs配列に加え、リターンアドレスを変数ebpに代入し、次のループでebp[1]から前のスタックフレームのベースアドレスを取得し、pcs配列に加え、再びリターンアドレスをebpに代入していく。
ベースアドレスが0か、カーネル空間外を指している場合にループを抜ける。<br />
スタックフレームが10個に満たなかった場合、2つめのfor文でpcs配列の残りのエントリに0を代入する。</p>
<p>spinlock.c</p>
<pre><code class="language-c">void
getcallerpcs(void *v, uint pcs[])
{
  uint *ebp;
  int i;

  ebp = (uint*)v - 2;
  for(i = 0; i &lt; 10; i++){
    if(ebp == 0 || ebp &lt; (uint*)KERNBASE || ebp == (uint*)0xffffffff)
      break;
    pcs[i] = ebp[1];     // saved %eip
    ebp = (uint*)ebp[0]; // saved %ebp
  }
  for(; i &lt; 10; i++)
    pcs[i] = 0;
}
</code></pre>
<h2><a class="header" href="#release関数" id="release関数">release関数</a></h2>
<p>この関数はspinlock構造体のロックを解放する。</p>
<p>基本的に<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_10_lock.html#acquire%E9%96%A2%E6%95%B0">acquire関数</a>の動作を反対から行う。
movl命令を用いたロック解放部分以外は上で確認した通り。</p>
<p>spinlock構造体のコールスタックとcpu構造体を0でリセットした後、__sync_synchronize関数でロック解放前と解放後の命令順序を保証する。<br />
ロックの解放は、既に現在のプロセッサが当該ロックを取得していることがholding関数により保証されているため、xchg命令ではなく、move命令でlockedフィールドに0を代入する。
c言語で <code>lk-\&gt;locked = 0</code> とぜず、拡張インラインアセンブリを使用する理由は、<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">「xv6 a simple, Unix-like teaching operating system」（リンク1）</a>の4章「Code: Locks」で説明されており、c言語の仕様では特段単一の代入命令がatomicに行われることを明記していないため。<br />
ロック解放後、popcli関数で必要に応じて割り込みを可能にする。</p>
<p>spinlock.c</p>
<pre><code class="language-c">void
release(struct spinlock *lk)
{
  if(!holding(lk))
    panic(&quot;release&quot;);

  lk-&gt;pcs[0] = 0;
  lk-&gt;cpu = 0;

  // Tell the C compiler and the processor to not move loads or stores
  // past this point, to ensure that all the stores in the critical
  // section are visible to other cores before the lock is released.
  // Both the C compiler and the hardware may re-order loads and
  // stores; __sync_synchronize() tells them both not to.
  __sync_synchronize();

  // Release the lock, equivalent to lk-&gt;locked = 0.
  // This code can't use a C assignment, since it might
  // not be atomic. A real OS would use C atomics here.
  asm volatile(&quot;movl $0, %0&quot; : &quot;+m&quot; (lk-&gt;locked) : );

  popcli();
}
</code></pre>
<h2><a class="header" href="#スリープロック" id="スリープロック">スリープロック</a></h2>
<p>このロックはロックが取れるまでプロセスをスリープ状態にしてプロセッサを明け渡す。
ディスクにアクセスする可能性がある場合等、長時間ロックを取得する可能性がある場合に使用する。</p>
<p>sleeplock構造体を使用する。
lockedフィールドでロックの状態を管理するが、独立性はspinlock構造体を使用して確保する。
また、後者はプロセスを起床させる際のチャネルとしても使用する。</p>
<p>スリープロックの流れは次の通り。<br />
<strong>まだ誰も取得していないスリープロックを取得するとき:</strong><br />
lockedフィールドを1にし、pidフィールドに自分のpidを代入する。
ロック使用後は、lockedとpidを0にリセットし、同ロックを必要としている他のプロセスの状態を実行可能状態にする。</p>
<p><strong>既に誰かが取得しているスリープロックを取得するとき:</strong><br />
自分（プロセス）のチャネルに取得したいスリープロックをセットし、スリープ状態になる。
スリープすると、コンテキストスイッチを行いスケジューラスレッドにプロセッサを明け渡す。<br />
スリープロックが解放されると、それを取っていたプロセスがチャネルを通してスリープ状態のプロセス（自分）を実行可能状態にする。<br />
あとはスケジューラスレッドが自分を実行してくれるまで待つ。<br />
もしも他のプロセスも同じロックを取るためにスリープしている場合、スケジューラがそちらを先に実行してしまうと自分は再びスリープ状態となり、ロック解放まで再度待つことになる。</p>
<p>sleeplock.h</p>
<pre><code class="language-c">struct sleeplock {
  uint locked;       // Is the lock held?
  struct spinlock lk; // spinlock protecting this sleep lock
  
  // For debugging:
  char *name;        // Name of lock.
  int pid;           // Process holding lock
};
</code></pre>
<h2><a class="header" href="#acquiresleep関数" id="acquiresleep関数">acquiresleep関数</a></h2>
<p>この関数はスリープロックを取る。
ロックが取れるまで自身をスリープ状態とする。</p>
<p>同じスリープロックの取得が同時に行われないように、まずsleeplock構造体のlkフィールド（spinlock構造体）のロックを取る。<br />
スリープする場合にはsleeplock構造体のアドレスを起床する際のチャネルとして用いる。<br />
スリープロックが取られていない場合はスリープしない。</p>
<p>sleeplock.c</p>
<pre><code class="language-c">void
acquiresleep(struct sleeplock *lk)
{
  acquire(&amp;lk-&gt;lk);
  while (lk-&gt;locked) {
    sleep(lk, &amp;lk-&gt;lk);
  }
  lk-&gt;locked = 1;
  lk-&gt;pid = myproc()-&gt;pid;
  release(&amp;lk-&gt;lk);
}
</code></pre>
<h2><a class="header" href="#sleep関数" id="sleep関数">sleep関数</a></h2>
<p>名前の通りスリープする。</p>
<p>もしも引数のspinlock構造体がプロセステーブルのロックではなかった場合、プロセステーブルのロックを取り、spinlock構造体のロックを解放する。
つまりプロセステーブルのロックを取りたい。
sched関数では、scheduler関数のプロセステーブルを走査するループの中、swtch関数の後のところに復帰する。
そこではプロセステーブルのロックが取得済みの前提で動作しており、ループ終了後にそのロックを解放する。
このためsleep関数内でsched関数を呼ぶ前にプロセステーブルのロックを取得しておく必要がある。</p>
<p>スリープする際には第一引数chanのアドレスをチャネルに設定する。
チャネルはproc構造体のchanフィールドで、他のプロセスがプロセステーブルから特定のプロセスを見つけるために使う。</p>
<p>ここではスリープとはsched関数内でスケジューラスレッドにコンテキストスイッチすることであるため、sched関数呼び出し以降は起床後に実行されることとなる。</p>
<p>proc.c</p>
<pre><code class="language-c">void
sleep(void *chan, struct spinlock *lk)
{
  struct proc *p = myproc();
  
  if(p == 0)
    panic(&quot;sleep&quot;);

  if(lk == 0)
    panic(&quot;sleep without lk&quot;);

  // Must acquire ptable.lock in order to
  // change p-&gt;state and then call sched.
  // Once we hold ptable.lock, we can be
  // guaranteed that we won't miss any wakeup
  // (wakeup runs with ptable.lock locked),
  // so it's okay to release lk.
  if(lk != &amp;ptable.lock){  //DOC: sleeplock0
    acquire(&amp;ptable.lock);  //DOC: sleeplock1
    release(lk);
  }
  // Go to sleep.
  p-&gt;chan = chan;
  p-&gt;state = SLEEPING;

  sched();

  // Tidy up.
  p-&gt;chan = 0;

  // Reacquire original lock.
  if(lk != &amp;ptable.lock){  //DOC: sleeplock2
    release(&amp;ptable.lock);
    acquire(lk);
  }
}
</code></pre>
<h2><a class="header" href="#sched関数" id="sched関数">sched関数</a></h2>
<p>sched関数はスケジューラスレッドにコンテキストスイッチする。</p>
<p>各if文でscheduler関数のプロセステーブルのループに戻るための準備ができているかを確認している。
準備ができていないとpanicしてしまう。
必要な準備は次の通り。</p>
<ul>
<li>ページテーブルのロックを取得していること</li>
<li>pushcli関数が1回以上呼ばれていること</li>
<li>自分のステータスが実行状態でないこと</li>
<li>割り込みが無効になっていること（eflagsレジスタのInterrupt enableビット）</li>
</ul>
<p>準備ができていることを確認後、自分のcpu構造体からintenaフィールドの値を退避する。
これは再びコンテキストスイッチされ今のプロセスに戻ってきた際に、intenaフィールドの値が変わっているかもしれないため。<br />
そしてswtch関数でスケジューラスレッドにコンテキストスイッチする。
swtch関数については<a href="https://kkmtyyz.github.io/xv6-notebook/chapter_05/05_22_scheduler.html">5.22. scheduler関数とmpmain関数</a>に書く。
関数呼び出しのような要領でコンテキストスイッチを行う。<br />
再び今のプロセスにコンテキストスイッチして戻ってきた際に、退避しておいたintenaフィールドの値を復元する。</p>
<p>proc.c</p>
<pre><code class="language-c">void
sched(void)
{
  int intena;
  struct proc *p = myproc();

  if(!holding(&amp;ptable.lock))
    panic(&quot;sched ptable.lock&quot;);
  if(mycpu()-&gt;ncli != 1)
    panic(&quot;sched locks&quot;);
  if(p-&gt;state == RUNNING)
    panic(&quot;sched running&quot;);
  if(readeflags()&amp;FL_IF)
    panic(&quot;sched interruptible&quot;);
  intena = mycpu()-&gt;intena;
  swtch(&amp;p-&gt;context, mycpu()-&gt;scheduler);
  mycpu()-&gt;intena = intena;
}
</code></pre>
<h2><a class="header" href="#releasesleep関数" id="releasesleep関数">releasesleep関数</a></h2>
<p>この関数はスリープロックを解放し、同ロックを必要としているプロセスを起床させる。</p>
<p>同じsleeplock構造体のロックの取得が同時に行われないよう、lkフィールド（spinlock構造体）のロックを取る。<br />
sleeplock構造体のアドレスをチャネルとして、wakeup関数でロックを必要としているプロセスを起床させる。</p>
<p>sleeplock.c</p>
<pre><code class="language-c">void
releasesleep(struct sleeplock *lk)
{
  acquire(&amp;lk-&gt;lk);
  lk-&gt;locked = 0;
  lk-&gt;pid = 0;
  wakeup(lk);
  release(&amp;lk-&gt;lk);
}
</code></pre>
<h2><a class="header" href="#wakeup関数" id="wakeup関数">wakeup関数</a></h2>
<p>wakeup関数は引数で渡されたチャネル（アドレス）を元に、スリープ状態のプロセスを実行可能状態にする。
実際のところはwakeup1関数を呼び出す。</p>
<p>プロセステーブルを走査し、同じチャネルを持っているスリープ状態のプロセスを探すため、プロセステーブルのロックを取る。<br />
wakeup1関数にチャネルを渡し、起床処理を行う。</p>
<p>wakeup関数とwakeup1関数に分かれている理由は、呼び出し元が既にプロセステーブルのロックを取得している場合に対応するため。
プロセステーブルのロックを取っていない場合はwakeup関数を呼び出し、既にロックを取っている場合はwakeup1関数を呼び出す。<br />
プロセステーブルを走査し、スリープ状態かつ同じチャネルを持っているプロセスがいる場合、そのプロセスの状態を実行可能状態にする。</p>
<p>proc.c</p>
<pre><code class="language-c">static void
wakeup1(void *chan)
{
  struct proc *p;

  for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)
    if(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan)
      p-&gt;state = RUNNABLE;
}

// Wake up all processes sleeping on chan.
void
wakeup(void *chan)
{
  acquire(&amp;ptable.lock);
  wakeup1(chan);
  release(&amp;ptable.lock);
}
</code></pre>
<h1><a class="header" href="#511-iノード" id="511-iノード">5.11. iノード</a></h1>
<p>スケジューラの実行までに使用するiノード周りの操作について書く。</p>
<ul>
<li><a href="chapter_05/05_11_inode.html#inode%E6%A7%8B%E9%80%A0%E4%BD%93">inode構造体</a></li>
<li><a href="chapter_05//chapter_05/05_11_inode.html#inode%E6%A7%8B%E9%80%A0%E4%BD%93%E3%81%AE%E4%BD%9C%E6%88%90iget%E9%96%A2%E6%95%B0">inode構造体の作成（iget関数）</a></li>
<li><a href="chapter_05//chapter_05/05_11_inode.html#%E3%83%AD%E3%83%83%E3%82%AFilockiunlock%E9%96%A2%E6%95%B0">ロック（ilock/iunlock関数）</a></li>
<li><a href="chapter_05//chapter_05/05_11_inode.html#%E5%8F%82%E7%85%A7%E3%82%AB%E3%82%A6%E3%83%B3%E3%82%BF%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%AF%E3%83%AA%E3%83%A1%E3%83%B3%E3%83%88idup%E9%96%A2%E6%95%B0">参照カウンタのインクリメント（idup数）</a></li>
<li><a href="chapter_05//chapter_05/05_11_inode.html#%E5%8F%82%E7%85%A7%E3%82%AB%E3%82%A6%E3%83%B3%E3%82%BF%E3%81%AE%E3%83%87%E3%82%AF%E3%83%AA%E3%83%A1%E3%83%B3%E3%83%88iput%E9%96%A2%E6%95%B0">参照カウンタのデクリメント（iput関数）</a></li>
<li><a href="chapter_05//chapter_05/05_11_inode.html#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E5%8F%96%E5%BE%97readi%E9%96%A2%E6%95%B0">ファイルデータの取得（readi関数）</a></li>
<li><a href="chapter_05//chapter_05/05_11_inode.html#%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%AE%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6bmap%E9%96%A2%E6%95%B0">ブロックの割り当て（bmap関数）</a></li>
<li><a href="chapter_05//chapter_05/05_11_inode.html#%E5%89%8A%E9%99%A4itrunc%E9%96%A2%E6%95%B0">削除（itrunc関数）</a></li>
<li><a href="chapter_05//chapter_05/05_11_inode.html#%E6%9B%B4%E6%96%B0iupdate%E9%96%A2%E6%95%B0">更新（iupdate関数）</a></li>
</ul>
<h2><a class="header" href="#inode構造体" id="inode構造体">inode構造体</a></h2>
<p>inodeについては、<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">「xv6 a simple, Unix-like teaching operating system」（リンク1）</a>の6章「File system」を読むとよい。</p>
<p>dinode構造体とinode構造体の2つがある。</p>
<p><strong>dinode構造体</strong><br />
ディスク上のiノードブロックにその情報が格納されてる。
typeフィールドは次の4つの状態を表す。</p>
<ul>
<li>0: 未使用</li>
<li>1: ファイル</li>
<li>2: ディレクトリ</li>
<li>3: デバイスファイル</li>
</ul>
<p>addrs配列はファイルの存在しているディスク上のブロック番号を持ち、「xv6 a simple, Unix-like teaching operating system」（リンク1）の図6-3「The representation of a file on disk」で分かりやすく図解されている。
要素数は13で、12番目（NDIRECT）までは直接ブロック番号が入っており、13番目はindirect blockのブロック番号が入っている。
ブロックサイズは512バイトで、ブロック番号は4バイトなので、indirect blockは128個のブロックを指すことができる。
つまりinode構造体は全部で140個（128+12）のブロックを指すことができる。
逆に言えば71680バイト（140*512）がファイルの最大サイズとなる。</p>
<p>にあるように、前12エントリがそのままデータブロックを指しており、13エントリ目は128エントリまで保持できる別のテーブルを参照している。
ブロックサイズが512バイトなので、dinode構造体から直接参照できるのは<code>12 * 512 = 6kB</code>まで。</p>
<p>fs.h</p>
<pre><code class="language-c">#define NDIRECT 12

/* 略 */

struct dinode {
  short type;           // File type
  short major;          // Major device number (T_DEV only)
  short minor;          // Minor device number (T_DEV only)
  short nlink;          // Number of links to inode in file system
  uint size;            // Size of file (bytes)
  uint addrs[NDIRECT+1];   // Data block addresses
};
</code></pre>
<p><strong>inode構造体</strong><br />
後半はdinode構造体のコピーになっている。<br />
validフィールドは既にディスクからdinodeの情報を読み出したか否かを示すフラグ。</p>
<p>file.h</p>
<pre><code class="language-c">struct inode {
  uint dev;           // Device number
  uint inum;          // Inode number
  int ref;            // Reference count
  struct sleeplock lock; // protects everything below here
  int valid;          // inode has been read from disk?

  short type;         // copy of disk inode
  short major;
  short minor;
  short nlink;
  uint size;
  uint addrs[NDIRECT+1];
};
</code></pre>
<p>inode構造体はicache構造体に持っておく。<br />
全部で50個持てる。逆に言えば50個以上開けない。</p>
<p>param.h</p>
<pre><code class="language-c">#define NINODE       50  // maximum number of active i-nodes
</code></pre>
<p>fs.c</p>
<pre><code class="language-c">struct {
  struct spinlock lock;
  struct inode inode[NINODE];
} icache;
</code></pre>
<h2><a class="header" href="#inode構造体の作成iget関数" id="inode構造体の作成iget関数">inode構造体の作成（iget関数）</a></h2>
<p>iノードキャッシュからinode構造体を返す。<br />
探しているiノードがキャッシュにある場合は参照カウンタをインクリメントしてそれを返し、無い場合はキャッシュ内の未使用エントリを初期化して返す。
ディスクからのデータ読み出しは行わないので、dinode構造体の持つ内容のコピーは行わない。
キャッシュからはデバイス番号とiノード番号を頼りにエントリを検索する。</p>
<p>fs.c</p>
<pre><code class="language-c">static struct inode*
iget(uint dev, uint inum)
{
  struct inode *ip, *empty;

  acquire(&amp;icache.lock);

  // Is the inode already cached?
  empty = 0;
  for(ip = &amp;icache.inode[0]; ip &lt; &amp;icache.inode[NINODE]; ip++){
    if(ip-&gt;ref &gt; 0 &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum){
      ip-&gt;ref++;
      release(&amp;icache.lock);
      return ip;
    }
    if(empty == 0 &amp;&amp; ip-&gt;ref == 0)    // Remember empty slot.
      empty = ip;
  }

  // Recycle an inode cache entry.
  if(empty == 0)
    panic(&quot;iget: no inodes&quot;);

  ip = empty;
  ip-&gt;dev = dev;
  ip-&gt;inum = inum;
  ip-&gt;ref = 1;
  ip-&gt;valid = 0;
  release(&amp;icache.lock);

  return ip;
}
</code></pre>
<h2><a class="header" href="#ロックilockiunlock関数" id="ロックilockiunlock関数">ロック（ilock/iunlock関数）</a></h2>
<p>iノードを使用する処理はファイルシステムを扱う処理なのでディスクにアクセスする可能性があり、長時間ロックを取得する可能性が高いためスリープロックを使用する。</p>
<p>ilock関数はinode構造体のロックを取り、dinode構造体のデータをまだ持っていない場合にバッファキャッシュやディスクからそれを読み込む。</p>
<p>dinode構造体のデータはbread関数で取得する。
bread関数はデータをデバイス番号とブロック番号を基にバッファキャッシュから探し、そこに無ければディスクからデータを読み込んでバッファキャッシュに加える。
ブロック番号はIBLOCKマクロを使用して、iノード番号とsuperblock構造体から求める。
superblock構造体は、大域変数sbがiinit関数で定義される。
スーパーブロックは<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">「xv6 a simple, Unix-like teaching operating system」（リンク1）</a>の図6-2における1番目のブロックで、ファイルシステムのサイズやデータブロック数等の情報を持っている。
IBLOCKマクロはinode番号をブロック当たりのiノード数で割り、それにiノード領域の開始ブロック番号を加算することで目的のiノードが含まれるブロック番号を求める。
ブロック当たりのiノード数はIPBとして定義されており、ブロックサイズをdinode構造体のサイズで割ったもの。</p>
<p>buf構造体のdataフィールドにはdinode構造体のデータがiノード番号順に並んでいるため、iノード番号をIPBで割った余り番目からデータを取り出す。<br />
その後dinode構造体の全フィールドをinode構造体にコピーし、最後にバッファキャッシュを始末する。</p>
<p>fs.h</p>
<pre><code class="language-c">#define IPB           (BSIZE / sizeof(struct dinode))

// Block containing inode i
#define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
</code></pre>
<p>fs.c</p>
<pre><code class="language-c">struct superblock sb;

/* 略 */

void
ilock(struct inode *ip)
{
  struct buf *bp;
  struct dinode *dip;

  if(ip == 0 || ip-&gt;ref &lt; 1)
    panic(&quot;ilock&quot;);

  acquiresleep(&amp;ip-&gt;lock);

  if(ip-&gt;valid == 0){
    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));
    dip = (struct dinode*)bp-&gt;data + ip-&gt;inum%IPB;
    ip-&gt;type = dip-&gt;type;
    ip-&gt;major = dip-&gt;major;
    ip-&gt;minor = dip-&gt;minor;
    ip-&gt;nlink = dip-&gt;nlink;
    ip-&gt;size = dip-&gt;size;
    memmove(ip-&gt;addrs, dip-&gt;addrs, sizeof(ip-&gt;addrs));
    brelse(bp);
    ip-&gt;valid = 1;
    if(ip-&gt;type == 0)
      panic(&quot;ilock: no type&quot;);
  }
}
</code></pre>
<p>ロックはiunlock関数で解放する。</p>
<p>fs.c</p>
<pre><code class="language-c">void
iunlock(struct inode *ip)
{
  if(ip == 0 || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; 1)
    panic(&quot;iunlock&quot;);

  releasesleep(&amp;ip-&gt;lock);
}
</code></pre>
<h2><a class="header" href="#参照カウンタのインクリメントidup関数" id="参照カウンタのインクリメントidup関数">参照カウンタのインクリメント（idup関数）</a></h2>
<p>inode構造体の参照カウンタをインクリメントする。</p>
<p>fs.c</p>
<pre><code class="language-c">struct inode*
idup(struct inode *ip)
{
  acquire(&amp;icache.lock);
  ip-&gt;ref++;
  release(&amp;icache.lock);
  return ip;
}
</code></pre>
<h2><a class="header" href="#参照カウンタのデクリメントiput関数" id="参照カウンタのデクリメントiput関数">参照カウンタのデクリメント（iput関数）</a></h2>
<p>この関数は引数のinode構造体ipの参照カウンタをデクリメントする。
また、ファイルデータをディスクから取得済みかつ他のファイル（ディレクトリエントリ）がリンクされておらず、誰からも参照されていない場合にiノードを解放する。
ここで言う解放は、addrsをバッファキャッシュごと全て解放しディスクに書き出すことでファイルを削除することを指す。
参照カウンタの値は誰からも参照されていない場合は1。</p>
<p>iunlockput関数はinode構造体のロックを解放し、iput関数を呼び出す。</p>
<p>fs.c</p>
<pre><code class="language-c">void
iput(struct inode *ip)
{
  acquiresleep(&amp;ip-&gt;lock);
  if(ip-&gt;valid &amp;&amp; ip-&gt;nlink == 0){
    acquire(&amp;icache.lock);
    int r = ip-&gt;ref;
    release(&amp;icache.lock);
    if(r == 1){
      // inode has no links and no other references: truncate and free.
      itrunc(ip);
      ip-&gt;type = 0;
      iupdate(ip);
      ip-&gt;valid = 0;
    }
  }
  releasesleep(&amp;ip-&gt;lock);

  acquire(&amp;icache.lock);
  ip-&gt;ref--;
  release(&amp;icache.lock);
}

/* 略 */

void
iunlockput(struct inode *ip)
{
  iunlock(ip);
  iput(ip);
}
</code></pre>
<h2><a class="header" href="#ファイルデータの取得readi関数" id="ファイルデータの取得readi関数">ファイルデータの取得（readi関数）</a></h2>
<p>この関数はファイルからデータを最大nバイト分dstに読み込む。</p>
<p>iノードがデバイスファイルの場合とそれ以外（ファイルあるいはディレクトリ）とで処理が分かれる。</p>
<p><strong>デバイスファイルの場合:</strong><br />
読み込みにはデバイス番号を頼りに<a href="chapter_05//chapter_05/05_09_consoleinit.html">devsw配列</a>の該当するread関数を使う。<br />
例えばコンソールならdevsw[1].readなので、consoleinit関数で設定した<a href="chapter_05//chapter_05/05_09_consoleinit.html#consoleread%E9%96%A2%E6%95%B0">consoleread関数</a>が実行される。</p>
<p><strong>ファイルあるいはディレクトリの場合:</strong><br />
ファイルのデータをoffバイト目から読み込み始める。<br />
ファイルサイズよりも読み込みサイズ（off+n）大きい場合は調整する。<br />
読み込むデータ（nバイト）がブロックを跨いでいる可能性があるため、ループで読み込む。<br />
mがループ毎にdstにコピーするバイト数を示し、totにはコピーした総バイト数を持つ。<br />
読み込みにはbread関数を使う。
この関数にはデバイス番号とブロック番号を渡す必要がある。
<a href="chapter_05//chapter_05/05_11_inode.html#%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%AE%E5%89%B2%E3%82%8A%E5%BD%93%E3%81%A6bmap%E9%96%A2%E6%95%B0">bmap関数</a>では第一引数のinode構造体のaddrsフィールドから、第二引数で指定されたバイト目があるブロック番号を得ることができる。<br />
基本的にはoffからそのブロックの終わりまでずつコピーしていく。<br />
例えばoffが600の場合、1ブロック512バイトなので、offは2ブロック目の88バイト目から始まる。
なので <code>512-88=424</code> バイトずつコピーしていく。
そして読み込みバイト数nがコピーしていく単位で割り切れない場合は、最後のループでnからコピー済みバイト数totの差だけコピーする。<br />
他の例として、nが1000の場合、3回目のループで残りコピーバイト数が <code>1000-424*2=152</code> なので、152バイトだけコピーする。
変数mにはこの動きをするために、minマクロを使用して残りコピーバイト数（n-tot）と基本的なコピー単位のどちらか小さい方を代入する。<br />
コピーバイト数mが決まると、<a href="chapter_05//chapter_05/05_09_consoleinit.html#memmove%E9%96%A2%E6%95%B0">memmove関数</a>でdstにブロックのデータ（bs-&gt;data）のオフセットの位置からその分だけコピーする。<br />
バッファキャッシュbpは読み込み後不要となるのでループ毎に解放する。
1ブロック分ずつコピーするわけではないので、次のループでも同じブロックをバッファキャッシュに読み込む可能性がある。
しかしここで解放しなければ、バッファキャッシュのサイズが30なのでコピー対象のデータが30ブロック以上の時にキャッシュが足りなくなりpanicしてしまう。</p>
<p>fs.c</p>
<pre><code class="language-c">#define min(a, b) ((a) &lt; (b) ? (a) : (b))

/* 略 */

int
readi(struct inode *ip, char *dst, uint off, uint n)
{
  uint tot, m;
  struct buf *bp;

  if(ip-&gt;type == T_DEV){
    if(ip-&gt;major &lt; 0 || ip-&gt;major &gt;= NDEV || !devsw[ip-&gt;major].read)
      return -1;
    return devsw[ip-&gt;major].read(ip, dst, n);
  }

  if(off &gt; ip-&gt;size || off + n &lt; off)
    return -1;
  if(off + n &gt; ip-&gt;size)
    n = ip-&gt;size - off;

  for(tot=0; tot&lt;n; tot+=m, off+=m, dst+=m){
    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));
    m = min(n - tot, BSIZE - off%BSIZE);
    memmove(dst, bp-&gt;data + off%BSIZE, m);
    brelse(bp);
  }
  return n;
}
</code></pre>
<h2><a class="header" href="#ブロックの割り当てbmap関数" id="ブロックの割り当てbmap関数">ブロックの割り当て（bmap関数）</a></h2>
<p>この関数はaddrsフィールドのbn番目のブロック番号を返す。
もしもbn番目が0でブロックが割り当てられていない場合、ディスクのdata領域から1ブロック割り当てる。</p>
<p>2つのif文に分かれており、前半はbnがaddrsの12番目までの処理を行い、後半はindirect block（13番目）の処理を行う。</p>
<p><strong>12番目まで:</strong><br />
addrsフィールドのbn番目からブロック番号を取り出す。
もしもbn番目が0でブロックが割り当てられていない場合、balloc関数でファイルシステムのdata領域から1ブロック割り当て、そのブロック番号をbn番目に入れる。</p>
<p><strong>indirect block:</strong><br />
bnをそのままindirect block内でのインデックスとするため、12減算する。<br />
NINDIRECTはindirect blockのエントリ数。<br />
indirect blockのブロック番号を取り出し、0の場合はballoc関数で1ブロック割り当てる。<br />
変数bpにbread関数でindirect blockを読み出し、そこからさらにbn番目のブロック番号を取り出す。
bn番目が0の場合も同様にブロックを割り当てる。
このとき、新たにブロックの割り当てを行うとindirect blockの内容を更新することになるため、log_write関数で変更をディスクに反映する。
log_write関数ではバッファキャッシュのB_DIRTYを立て、後々呼び出されるwrite_log関数でディスクに書き込みを行う。<br />
bpをbrelse関数で解放し、呼び出し元にブロック番号addrを返して終了。</p>
<p>fs.h</p>
<pre><code class="language-c">#define NDIRECT 12
#define NINDIRECT (BSIZE / sizeof(uint))
</code></pre>
<p>fs.c</p>
<pre><code class="language-c">static uint
bmap(struct inode *ip, uint bn)
{
  uint addr, *a;
  struct buf *bp;

  if(bn &lt; NDIRECT){
    if((addr = ip-&gt;addrs[bn]) == 0)
      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);
    return addr;
  }
  bn -= NDIRECT;

  if(bn &lt; NINDIRECT){
    // Load indirect block, allocating if necessary.
    if((addr = ip-&gt;addrs[NDIRECT]) == 0)
      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);
    bp = bread(ip-&gt;dev, addr);
    a = (uint*)bp-&gt;data;
    if((addr = a[bn]) == 0){
      a[bn] = addr = balloc(ip-&gt;dev);
      log_write(bp);
    }
    brelse(bp);
    return addr;
  }

  panic(&quot;bmap: out of range&quot;);
}
</code></pre>
<h2><a class="header" href="#削除itrunc関数" id="削除itrunc関数">削除（itrunc関数）</a></h2>
<p>この関数はiノードのデータを解放する。
ここで言う解放は、addrsをバッファキャッシュごと全て解放しディスクに書き出すことでファイルを削除することを指す。</p>
<p>ファイルシステム上のブロックを未使用にマークする。<br />
動作はbmap関数とほぼ同様で、addrsフィールドを走査してbfree関数でブロックを解放しつつ0を代入していく。<br />
その後ファイルサイズも0とし、iupdate関数を呼び出してdinode構造体に変更を反映する。</p>
<p>fs.c</p>
<pre><code class="language-c">static void
itrunc(struct inode *ip)
{
  int i, j;
  struct buf *bp;
  uint *a;

  for(i = 0; i &lt; NDIRECT; i++){
    if(ip-&gt;addrs[i]){
      bfree(ip-&gt;dev, ip-&gt;addrs[i]);
      ip-&gt;addrs[i] = 0;
    }
  }

  if(ip-&gt;addrs[NDIRECT]){
    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);
    a = (uint*)bp-&gt;data;
    for(j = 0; j &lt; NINDIRECT; j++){
      if(a[j])
        bfree(ip-&gt;dev, a[j]);
    }
    brelse(bp);
    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);
    ip-&gt;addrs[NDIRECT] = 0;
  }

  ip-&gt;size = 0;
  iupdate(ip);
}
</code></pre>
<h2><a class="header" href="#更新iupdate関数" id="更新iupdate関数">更新（iupdate関数）</a></h2>
<p>この関数はinode構造体の内容をdinode構造体にコピーし、その変更をディスクに反映する。</p>
<p>ディスク上にあるdinode構造体はbread関数で取得する。
その際のブロック番号は<a href="chapter_05//chapter_05/05_11_inode.html#%E3%83%AD%E3%83%83%E3%82%AFilockiunlock%E9%96%A2%E6%95%B0">IBLOCKマクロ</a>で算出する。<br />
log_write関数で変更をディスクに反映する。
この関数ではバッファキャッシュのB_DIRTYを立て、後々呼び出されるwrite_log関数でディスクに書き込みを行う。</p>
<p>fs.c</p>
<pre><code class="language-c">void
iupdate(struct inode *ip)
{
  struct buf *bp;
  struct dinode *dip;

  bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));
  dip = (struct dinode*)bp-&gt;data + ip-&gt;inum%IPB;
  dip-&gt;type = ip-&gt;type;
  dip-&gt;major = ip-&gt;major;
  dip-&gt;minor = ip-&gt;minor;
  dip-&gt;nlink = ip-&gt;nlink;
  dip-&gt;size = ip-&gt;size;
  memmove(dip-&gt;addrs, ip-&gt;addrs, sizeof(ip-&gt;addrs));
  log_write(bp);
  brelse(bp);
}
</code></pre>
<h1><a class="header" href="#512-バッファキャッシュとディスクの読み書き" id="512-バッファキャッシュとディスクの読み書き">5.12. バッファキャッシュとディスクの読み書き</a></h1>
<p>スケジューラの実行までに使用するバッファキャッシュ周りの操作について書く。</p>
<ul>
<li><a href="chapter_05//chapter_05/05_12_bcache.html#buf%E6%A7%8B%E9%80%A0%E4%BD%93">buf構造体</a></li>
<li><a href="chapter_05//chapter_05/05_12_bcache.html#buf%E6%A7%8B%E9%80%A0%E4%BD%93%E3%81%AE%E5%8F%96%E5%BE%97bread%E9%96%A2%E6%95%B0">buf構造体の取得（bread関数）</a></li>
<li><a href="chapter_05//chapter_05/05_12_bcache.html#buf%E6%A7%8B%E9%80%A0%E4%BD%93%E3%81%AE%E6%9B%B8%E3%81%8D%E8%BE%BC%E3%81%BFbwrite%E9%96%A2%E6%95%B0">buf構造体の書き込み（bwrite関数）</a></li>
<li><a href="chapter_05//chapter_05/05_12_bcache.html#%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%81%AE%E8%AA%AD%E3%81%BF%E6%9B%B8%E3%81%8Diderw%E9%96%A2%E6%95%B0">ディスクの読み書き（iderw関数）</a></li>
<li><a href="chapter_05/">データブロックの割り当て（balloc関数）</a></li>
<li><a href="chapter_05/">データブロックの解放（bfree関数）</a></li>
</ul>
<h2><a class="header" href="#buf構造体" id="buf構造体">buf構造体</a></h2>
<p>バッファキャッシュについては、<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">「xv6 a simple, Unix-like teaching operating system」（リンク1）</a>の6章「File system」を読むとよい。</p>
<p>buf構造体はディスクから読み込んだ1ブロック分のデータをキャッシュしておくための構造体。<br />
30個分を大域変数bcacheのbufフィールドに持つ。
bcache構造体はbinit関数で初期化される。</p>
<p>バッファキャッシュは循環リストになっており、各buf構造体のnextフィールドとprevフィールドでリンクする。
アクセスする際にはbcache構造体のheadフィールドを基点として、nextかprevでどちらかに回って走査する。
直近使用されたバッファはnext側の先頭に移動されるため、欲しいデータが既にバッファされているか確認するときはnext側に回る。
逆にデータをバッファする際は、未使用のバッファを探すためにprev側から回る。<br />
buf構造体のflagsフィールドは0x0が未使用、B_VALID（0x2）が使用中、B_DIRTY（0x4）が変更済みを示す。<br />
dataフィールドに1ブロック分のデータを持つ。</p>
<p>bio.c</p>
<pre><code class="language-c">struct {
  struct spinlock lock;
  struct buf buf[NBUF];

  // Linked list of all buffers, through prev/next.
  // head.next is most recently used.
  struct buf head;
} bcache;
</code></pre>
<p>buf.h</p>
<pre><code class="language-c">struct buf {
  int flags;
  uint dev;
  uint blockno;
  struct sleeplock lock;
  uint refcnt;
  struct buf *prev; // LRU cache list
  struct buf *next;
  struct buf *qnext; // disk queue
  uchar data[BSIZE];
};
#define B_VALID 0x2  // buffer has been read from disk
#define B_DIRTY 0x4  // buffer needs to be written to disk
</code></pre>
<h2><a class="header" href="#buf構造体の取得bread関数" id="buf構造体の取得bread関数">buf構造体の取得（bread関数）</a></h2>
<p>bread関数を使用して、欲しいブロックのbuf構造体を取得する。<br />
ブロックがバッファキャッシュに存在しない場合は、空のエントリにディスクからブロックを読み込む。
バッファキャッシュからの取得はbget関数で行い、ディスクからの読み込みは<a href="chapter_05//chapter_05/05_12_bcache.html#%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%81%AE%E8%AA%AD%E3%81%BF%E6%9B%B8%E3%81%8Diderw%E9%96%A2%E6%95%B0">iderw関数</a>で行う。</p>
<p>bio.c</p>
<pre><code class="language-c">struct buf*
bread(uint dev, uint blockno)
{
  struct buf *b;

  b = bget(dev, blockno);
  if((b-&gt;flags &amp; B_VALID) == 0) {
    iderw(b);
  }
  return b;
}
</code></pre>
<p>bget関数はデバイス番号とブロック番号を用いてバッファキャッシュからbuf構造体を探し、無ければ未使用のバッファを返す。<br />
最近キャッシュされた順に探すため、headからnext方向に走査する。
キャッシュを見つけた場合はbuf構造体の参照カウンタをインクリメントし、スリープロックを取る。
見つからなかった場合は未使用のbuf構造体を探すため、headからprev方向に走査する。<br />
もしもキャッシュが30個全て使用されていた場合はpanicする。</p>
<p>bio.c</p>
<pre><code class="language-c">static struct buf*
bget(uint dev, uint blockno)
{
  struct buf *b;

  acquire(&amp;bcache.lock);

  // Is the block already cached?
  for(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next){
    if(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno){
      b-&gt;refcnt++;
      release(&amp;bcache.lock);
      acquiresleep(&amp;b-&gt;lock);
      return b;
    }
  }

  // Not cached; recycle an unused buffer.
  // Even if refcnt==0, B_DIRTY indicates a buffer is in use
  // because log.c has modified it but not yet committed it.
  for(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev){
    if(b-&gt;refcnt == 0 &amp;&amp; (b-&gt;flags &amp; B_DIRTY) == 0) {
      b-&gt;dev = dev;
      b-&gt;blockno = blockno;
      b-&gt;flags = 0;
      b-&gt;refcnt = 1;
      release(&amp;bcache.lock);
      acquiresleep(&amp;b-&gt;lock);
      return b;
    }
  }
  panic(&quot;bget: no buffers&quot;);
}
</code></pre>
<h2><a class="header" href="#buf構造体の書き込みbwrite関数" id="buf構造体の書き込みbwrite関数">buf構造体の書き込み（bwrite関数）</a></h2>
<p>iderw関数でディスクへbuf構造体を書き出す。</p>
<p>void</p>
<pre><code class="language-c">bwrite(struct buf *b)
{
  if(!holdingsleep(&amp;b-&gt;lock))
    panic(&quot;bwrite&quot;);
  b-&gt;flags |= B_DIRTY;
  iderw(b);
}
</code></pre>
<h2><a class="header" href="#ディスクの読み書きiderw関数" id="ディスクの読み書きiderw関数">ディスクの読み書き（iderw関数）</a></h2>
<p>buf構造体をidequeueにエンキューし、それがキューの先頭である場合にディスクの読み込み或いは書き込み処理を行う。</p>
<p>buf構造体のデバイス番号が0でなかった場合、かつhavedisk1フラグが0だった場合はpanicする。
ディスクはカーネルイメージのディスク0と、ファイルシステムイメージのディスク1の2つのみであるため、デバイス番号は0か1になる。
また、デバイス番号が1ならば、ファイルシステムイメージの存在が確認されている必要があり、havedisk1フラグでそれを確認できる。
このフラグはideinit関数でディスクをチェックする際に設定される。</p>
<p>ideへの要求となるbuf構造体はide.cで定義されているidequeueにエンキューされ、idestart関数でそれをひとつずつideに処理してもらう。
iderw関数では、もしも引数のbuf構造体がidequeueの先頭だった場合、idestart関数でideに処理要求を出す。
ideの読み書きが終わるまではスリープ状態となり、割り込みを待つ。
ideの処理が終わると、割り込みによりideintr関数が実行され、その中でidequeueからデキューされ、順次idestart関数が呼ばれる。</p>
<p>ide.c</p>
<pre><code class="language-c">static struct buf *idequeue;

/* 略 */

void
iderw(struct buf *b)
{
  struct buf **pp;

  if(!holdingsleep(&amp;b-&gt;lock))
    panic(&quot;iderw: buf not locked&quot;);
  if((b-&gt;flags &amp; (B_VALID|B_DIRTY)) == B_VALID)
    panic(&quot;iderw: nothing to do&quot;);
  if(b-&gt;dev != 0 &amp;&amp; !havedisk1)
    panic(&quot;iderw: ide disk 1 not present&quot;);

  acquire(&amp;idelock);  //DOC:acquire-lock

  // Append b to idequeue.
  b-&gt;qnext = 0;
  for(pp=&amp;idequeue; *pp; pp=&amp;(*pp)-&gt;qnext)  //DOC:insert-queue
    ;
  *pp = b;

  // Start disk if necessary.
  if(idequeue == b)
    idestart(b);

  // Wait for request to finish.
  while((b-&gt;flags &amp; (B_VALID|B_DIRTY)) != B_VALID){
    sleep(b, &amp;idelock);
  }


  release(&amp;idelock);
}
</code></pre>
<p>idestart関数はideにbuf構造体に応じたリクエストを出す。<br />
ideコントローラのレジスタに書き込みを行うことでそれを行う。</p>
<p>ide.cの1行目に、これはPIOベースのシンプルなIDEドライバコードであるとのコメントがある。</p>
<p>アクセスしているレジスタとデータの意味は<a href="https://wiki.osdev.org/ATA_PIO_Mode">「OSDev ATA PIO Mode」（リンク23）</a>に記載されている。
関数内に出てくる0x1f7はリンクの「Addressing Modes」の「Registers」によると、読み込み時はステータスレジスタ、書き込み時はコマンドレジスタとなり、コマンドは<a href="https://wiki.osdev.org/ATA_Command_Matrix">「OSDev ATA Command Matrix」（リンク24）</a>に一覧としてまとまっている。</p>
<p>読み書きを行うブロックの指定にはLBA方式を使用する。
LBAについては<a href="https://wiki.osdev.org/LBA">「OSDev LBA」（リンク25）</a>に記載されている。
フロッピーディスクなどの場合はCHSという方法でセクタにアクセスする。</p>
<p>変数sector_per_blockからwrite_cmdまでの値は以下。</p>
<ul>
<li>sector_per_block: いずれも512バイトなので1</li>
<li>sector: ブロックがある（はじまる）セクタ番号（LBA）。
ブロックサイズとセクタサイズが等しいので、ブロックサイズがそのまま求める番号となる。</li>
<li>read_cmd: 読み込みに使用するコマンド。
コマンドは「OSDev ATA Command Matrix」（リンク24）に載っている。
セクタサイズとブロックサイズが異なる場合、複数のセクタを読む0xc4（IDE_CMD_RDMUL）とし、等しい場合はそのセクタだけを読む0x20（IDE_CMD_READ）とする。</li>
<li>write_cmd: 書き込みに使用するコマンド。
複数セクタを書く場合は0xc5（IDE_CMD_WRMUL）、ひとつの場合は0x30（IDE_CMD_WRITE）とする。</li>
</ul>
<p>ideにコマンドをリクエストする前に、ブロックサイズがセクタサイズの7倍より大きくないことを確認するが、なぜこのチェックが必要なのかはわからない。</p>
<p>idewait関数でドライブがビジーでもエラーでもなくなるまで待つ。</p>
<p>読み書きの設定は以下。
デバイスコントロールレジスタ（0x3f6）に0を書き込み、1bit目（nIEN）を0にすることでドライブの割り込みを有効化する。<br />
セクタカウントレジスタ（0x1f2）に、sector_per_blockを設定する。ここでは1。<br />
LBAloレジスタ（0x1f3）に、LBAの1バイト目を設定する。<br />
レジスタが8bitなので、LBAは4つに分けて設定する。<br />
LBAmidレジスタ（0x1f4）に、LBAの2バイト目を設定する。<br />
LBAhiレジスタ（0x1f5）に、LBAの3バイト目を設定する。<br />
ドライブ/ヘッドレジスタ（0x1f6）の各bitを設定する。
「OSDev ATA PIO Mode」（リンク23）の「Addressing Modes」の「Drive / Head Register (I/O base + 6)」を見ると各bitの役割が分かる。
5bitと7bitは常に1、6bitはLBAを使用する場合1とするため、ここでは0xe0をセット。
4bitはドライブ番号なのでbuf構造体のdevフィールドの1bitをセット。
0～3bitにはLBAの24～27bitをセットする。</p>
<p>ideにコマンドを発行する。
buf構造体のflagsフィールドの変更済みフラグ（B_DIRTY）が立っている場合は書き込み、そうでなければ読み込みを行う。</p>
<p><strong>書き込みの場合:</strong><br />
コマンドレジスタ（0x1f7）に書き込みコマンド（write_cmd）を書き込み、データレジスタ（0x1f0）に<a href="chapter_05//chapter_05/05_02_kinit2.html#memset%E9%96%A2%E6%95%B0">outsl関数</a>でbuf構造体のdataフィールドの内容を128回に分けて4バイトずつ書き込む。</p>
<p><strong>読み込みの場合:</strong><br />
コマンドレジスタ（0x1f0）に読み込みコマンド（read_cmd）を書き込む。</p>
<p>書き込み終了あるいは、読み込み準備の完了により、ideコントローラから割り込みが入り、最終的にはideintr関数が呼び出される。</p>
<p>ide.c</p>
<pre><code class="language-c">static void
idestart(struct buf *b)
{
  if(b == 0)
    panic(&quot;idestart&quot;);
  if(b-&gt;blockno &gt;= FSSIZE)
    panic(&quot;incorrect blockno&quot;);
  int sector_per_block =  BSIZE/SECTOR_SIZE;
  int sector = b-&gt;blockno * sector_per_block;
  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
  int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;

  if (sector_per_block &gt; 7) panic(&quot;idestart&quot;);

  idewait(0);
  outb(0x3f6, 0);  // generate interrupt
  outb(0x1f2, sector_per_block);  // number of sectors
  outb(0x1f3, sector &amp; 0xff);
  outb(0x1f4, (sector &gt;&gt; 8) &amp; 0xff);
  outb(0x1f5, (sector &gt;&gt; 16) &amp; 0xff);
  outb(0x1f6, 0xe0 | ((b-&gt;dev&amp;1)&lt;&lt;4) | ((sector&gt;&gt;24)&amp;0x0f));
  if(b-&gt;flags &amp; B_DIRTY){
    outb(0x1f7, write_cmd);
    outsl(0x1f0, b-&gt;data, BSIZE/4);
  } else {
    outb(0x1f7, read_cmd);
  }
}
</code></pre>
<p>idewait関数はドライブがビジーでもエラーでもなくなるまでwhileループで待つ。<br />
引数checkerrに0を渡すとエラーチェックはせず、1を渡すとドライブのエラーをチェックし、エラーの場合に-1を返してくれる。<br />
ループの終了条件はステータスレジスタ（0x1f7）を読み取り、7bitのビジービット（IDE_BSY）が0、かつ6bitのレディビット（IDE_DRDY）が1になること。<br />
エラーチェックではステータスレジスタの5bitドライブ障害エラービット（IDE_DF）あるいは0bitエラービット（IDE_ERR）を確認し、いずれかが1の場合に-1を返す。</p>
<p>ide.c</p>
<pre><code class="language-c">#define IDE_BSY       0x80
#define IDE_DRDY      0x40
#define IDE_DF        0x20
#define IDE_ERR       0x01

/* 略 */

static int
idewait(int checkerr)
{
  int r;

  while(((r = inb(0x1f7)) &amp; (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
    ;
  if(checkerr &amp;&amp; (r &amp; (IDE_DF|IDE_ERR)) != 0)
    return -1;
  return 0;
}
</code></pre>
<p>まだ割り込みベクタの初期化を読むのは先になるが、動きとしては、このあとディスクの準備ができるとideコントローラからirq14番で割り込みが入り、IOAPICのリダイレクトテーブルによって割り込みベクタ 46(32 + 14)番がtrap関数にわたされ、ideintr関数により読み込みが行われる。</p>
<p>ideintr関数はidequeueの先頭のbuf構造体のflagsフィールドに応じてディスクから読み込みを行う。</p>
<p>もしもbuf構造体のflagsフィールドの変更済みフラグ（B_DIRTY）が0で、かつidewait関数でドライブの準備ができている場合、ディスクから読み出しを行う。
読み出しは<a href="chapter_05//chapter_03/03_02_bootmain.html#inb%E9%96%A2%E6%95%B0outb%E9%96%A2%E6%95%B0insl%E9%96%A2%E6%95%B0">insl関数</a>でコントロールレジスタ（0x1f0）からbuf構造体のdataフィールドにブロックサイズ分読み込む。
次に、buf構造体のflagsフィールドの読み込み済みフラグ（B_VALID）を1にし、変更済みフラグ（B_DIRTY）をビット反転して論理積を取って0にする。</p>
<p>読み込みを待っているプロセスを起床し、idequeueにエントリがまだ残っている場合は次のエントリを引数としてidestart関数を呼び出す。</p>
<p>ide.c</p>
<pre><code class="language-c">void
ideintr(void)
{
  struct buf *b;

  // First queued buffer is the active request.
  acquire(&amp;idelock);

  if((b = idequeue) == 0){
    release(&amp;idelock);
    return;
  }
  idequeue = b-&gt;qnext;

  // Read data if needed.
  if(!(b-&gt;flags &amp; B_DIRTY) &amp;&amp; idewait(1) &gt;= 0)
    insl(0x1f0, b-&gt;data, BSIZE/4);

  // Wake process waiting for this buf.
  b-&gt;flags |= B_VALID;
  b-&gt;flags &amp;= ~B_DIRTY;
  wakeup(b);

  // Start disk on next buf in queue.
  if(idequeue != 0)
    idestart(idequeue);

  release(&amp;idelock);
}
</code></pre>
<h2><a class="header" href="#データブロックの割り当てballoc関数" id="データブロックの割り当てballoc関数">データブロックの割り当て（balloc関数）</a></h2>
<p>balloc関数はファイルシステムのdata領域で空いているブロックを探してそのブロック番号を返す。
ファイルシステムのbitmap領域に当該ブロックを使用済みとしてマークする。</p>
<p>bitmap領域に関しては、教科書<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">「xv6 a simple, Unix-like teaching operating system」（リンク1）</a>の6章「File system」の「Code: Block allocator」で説明されている。<br />
bitmap領域の1bitがファイルシステム上の1ブロックを表しており、使用済みか否かを管理している。
bitmap領域が何番目のブロックから始まるのかといったファイルシステムの情報は、superblockにある。
これは後々initプロセス実行時に呼び出されるforkret関数の中でiinit関数を呼び出し、superblock構造体の大域変数sbに読み込む。</p>
<p>この関数は二重のforループになっており、外側でbitmap領域のブロックを、内側でそのブロックのbitを走査する。<br />
<strong>外側ループ:</strong><br />
変数bはbitmap領域のbitの番号を表すと同時に、ファイルシステムのブロック番号でもある。
BPBマクロはブロックあたりのbitmapのbit数を表す（512*8）ので、bはブロックに含まれるbit数（4096）ずつ増加することになる。
終了条件はbがファイルシステムの総ブロックサイズsb.size（1000ブロック）を越えるときなので、fs.imgの場合はこのループは1度しか回らない。<br />
次にbitmap領域のブロックをbuf構造体のポインタbpに取り出す。
ブロックの取り出しにはbread関数を使用し、ブロック番号の指定はBBLOCKマクロで行う。
BBLOCKマクロはbitmap領域のbビット目が含まれるブロック番号を返してくれる。
これはbをBPBで割ってブロック番号を割り出し、bitmap領域の開始ブロックsb.bmapstartに加算して求めている。</p>
<p><strong>内側ループ:</strong><br />
bitmap領域の現在のブロックのbitを1つずつ走査し、0になっているbit（未使用のブロック番号）を探す。<br />
変数biをブロックの総bit数（512*8）までインクリメントしていく。
ブロックの全てのbitを走査すると言ってもbuf構造体bpのdataフィールドからアクセスできるのは1バイトずつなので、変数mを8bit分のフラグとして、0bitから順に7bitまで1を立てていってその論理積でbitを調べる。
なので、mにはbiを8で割った余りだけ左シフトした1を代入していく。
bpのdataフィールドの各bitをmで論理積してブロックの使用状況を調べる。
もしもbitが0で、ブロックb+biが使用されていないとき、今度はmの論理和でbpのdataフィールドのbitを立てて使用済みにマークする。
bpが更新されたので、log_write関数で変更をディスクに反映し、brelse関数でbpを解放する。
bzero関数で使用済みにマークしたブロック（b+bi番目）を0埋めし、呼び出し元にブロック番号を返す。
bzero関数は引数devのデバイスの引数bnoのブロック番号で示されるブロックを0埋めして、log_write関数でディスクに書き出す。<br />
もしもbitmap領域のbitが全て1で、未使用のブロックが存在しないときは、panicする。</p>
<p>fs.h</p>
<pre><code class="language-c">#define BPB           (BSIZE*8)

/* 略 */

#define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
</code></pre>
<p>fs.c</p>
<pre><code class="language-c">static void
bzero(int dev, int bno)
{
  struct buf *bp;

  bp = bread(dev, bno);
  memset(bp-&gt;data, 0, BSIZE);
  log_write(bp);
  brelse(bp);
}

/* 略 */

static uint
balloc(uint dev)
{
  int b, bi, m;
  struct buf *bp;

  bp = 0;
  for(b = 0; b &lt; sb.size; b += BPB){
    bp = bread(dev, BBLOCK(b, sb));
    for(bi = 0; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++){
      m = 1 &lt;&lt; (bi % 8);
      if((bp-&gt;data[bi/8] &amp; m) == 0){  // Is block free?
        bp-&gt;data[bi/8] |= m;  // Mark block in use.
        log_write(bp);
        brelse(bp);
        bzero(dev, b + bi);
        return b + bi;
      }
    }
    brelse(bp);
  }
  panic(&quot;balloc: out of blocks&quot;);
}
</code></pre>
<h2><a class="header" href="#データブロックの解放bfree関数" id="データブロックの解放bfree関数">データブロックの解放（bfree関数）</a></h2>
<p>この関数はデバイスdevのb番目のブロックを解放する。<br />
balloc関数と同じ要領でファイルシステムのbitmap領域のb番目のbitを0にする。<br />
log_write関数でディスクに変更を反映し、brelse関数でバッファキャッシュを解放する。</p>
<p>fs.c</p>
<pre><code class="language-c">static void
bfree(int dev, uint b)
{
  struct buf *bp;
  int bi, m;

  bp = bread(dev, BBLOCK(b, sb));
  bi = b % BPB;
  m = 1 &lt;&lt; (bi % 8);
  if((bp-&gt;data[bi/8] &amp; m) == 0)
    panic(&quot;freeing free block&quot;);
  bp-&gt;data[bi/8] &amp;= ~m;
  log_write(bp);
  brelse(bp);
}
</code></pre>
<h1><a class="header" href="#513-uartinit関数" id="513-uartinit関数">5.13. uartinit関数</a></h1>
<p>この関数はシリアルポートがある場合はそれを初期化し、シリアルポートを通して画面に「xv6...」と表示する。</p>
<p>シリアルポートへのアクセスは<a href="http://bochs.sourceforge.net/techspec/PORTS.LST">「XT, AT and PS/2 I/O port addresses」（リンク11）</a>によると、0x3f8～0x3ffで行える。<br />
個々のレジスタの役割や設定値に関しては<a href="https://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming">「Serial Programming/8250 UART Programming」（リンク28）</a>に詳しく記載がある。
UARTは12のレジスタに8つのポートからアクセスする。
各レジスタへのアクセス方法はリンク28の表「UART Registers」にまとまっている。
ポートへの読み書きとDivisor Latch Access Bit（DLAB）の状態によって切り替わる。</p>
<p>uart.cではシリアルポートの有無を示すフラグとして、int型の静的変数uartが定義されている。
この値が1のときシリアルポートが有る。
また、uart.cでは定数COM1が値0x3f8で定義されている。</p>
<p>まずUARTの設定は次の通り。</p>
<ul>
<li><strong>FIFO:</strong> FIFOコントロールレジスタ（+2）に0を設定し、FIFOを無効化する。
リンク28の「FIFO Control Register」を読むと、uartの入出力はFIFOの形でバッファできると書いてあるが、xv6では使用しない。</li>
<li><strong>DLAB:</strong> ラインコントロールレジスタ（+3）に0x80を設定し、DLABを1にする。</li>
<li><strong>ボーレート:</strong> Divisor Latch Low Byteレジスタ（+0, DLABは1）に12を設定し、ボーレートを9600に設定する。
UARTチップは一般的に115.2kHzで動作するクロックを持っており、ここではボーレート9600で送信したいので12を設定する。
各ボーレートと設定すべき値に関してはリンク28の表「Divisor Latch Byte Values (common baud rates)」にまとまっている。
表によるとDivisor Latch Hight Byteレジスタ（+1）には0を設定しなければならないため、そのようにする。</li>
<li><strong>ワードサイズ:</strong> ラインコントロールレジスタ（+3）に0x03を設定し、DLABを0にするとともに、ワードサイズを8bitに設定する。
ワードサイズの設定はラインコントロールレジスタの0bitと1bitの組み合わせにより、5bitから8bitまで設定できる。</li>
<li><strong>フロー制御:</strong> モデムコントロールレジスタ（+4）に0を設定する。
このレジスタにより、ソフトウェアでハードウェアのフロー制御を行えるが、使用しないので0で初期化する。</li>
</ul>
<p>シリアルポートの有無を確認する。
有無というより、UARTを使用してシリアルデータ通信が可能か否かを確認している。<br />
ラインステータスレジスタ（+5）の値が0xffと等しくない場合、シリアルポートが使用可能であることを示す。
スレジスタの各bitの役割についてはリンク28の「Line Status Register」に詳しく載っている。
特段0xffの場合に使用できないというようなことはないようだが、全てのbitが立っている状況が普通ではないことは分かる。
特にbit2（Parity Error）やbit3（Framing Error）が1になっていては通信はできない。</p>
<p>シリアルポートが使用できる場合、割り込みの設定を行う。<br />
割り込み識別レジスタ（+2）を読み、以前の割り込みに関する情報をクリアする。<br />
レシーバーバッファレジスタ（+0, DLABは0）を読み、バッファ内のデータをクリアする。<br />
<a href="chapter_05//chapter_05/05_09_consoleinit.html#ioapicenable%E9%96%A2%E6%95%B0">ioapicenable関数</a>でシリアルポート（COM1）からの割り込みの設定と有効化をする。
IOAPICのリダイレクトテーブルにIRQ4番からの割り込みをIRQ36番としてBSP（cpu0）のLAPICにリダイレクトするよう設定する。</p>
<p>最後に「xv6...」という文字列をuartputc関数を使用して1文字ずつ画面に表示する。</p>
<p>uart.c</p>
<pre><code class="language-c">#define COM1    0x3f8

static int uart;    // is there a uart?

void
uartinit(void)
{
  char *p;

  // Turn off the FIFO
  outb(COM1+2, 0);

  // 9600 baud, 8 data bits, 1 stop bit, parity off.
  outb(COM1+3, 0x80);    // Unlock divisor
  outb(COM1+0, 115200/9600);
  outb(COM1+1, 0);
  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
  outb(COM1+4, 0);
  outb(COM1+1, 0x01);    // Enable receive interrupts.

  // If status is 0xFF, no serial port.
  if(inb(COM1+5) == 0xFF)
    return;
  uart = 1;

  // Acknowledge pre-existing interrupt conditions;
  // enable interrupts.
  inb(COM1+2);
  inb(COM1+0);
  ioapicenable(IRQ_COM1, 0);

  // Announce that we're here.
  for(p=&quot;xv6...\n&quot;; *p; p++)
    uartputc(*p);
}
</code></pre>
<p>traps.h</p>
<pre><code class="language-c">#define IRQ_COM1         4
</code></pre>
<h2><a class="header" href="#uartgetc関数" id="uartgetc関数">uartgetc関数</a></h2>
<p>UARTのラインステータスレジスタ（+5）のData Ready（0bit）を見て、データの準備ができていることを確認する。<br />
レシーババッファレジスタ（+0, DLABは0）から入力されたデータを呼び出し元に返す。
シリアルポートではasciiコードがやり取りされるので、特に変換処理等はない。</p>
<p>uart.c</p>
<pre><code class="language-c">#define COM1    0x3f8

/* 略 */

static int
uartgetc(void)
{
  if(!uart)
    return -1;
  if(!(inb(COM1+5) &amp; 0x01))
    return -1;
  return inb(COM1+0);
}
</code></pre>
<h2><a class="header" href="#uartputc関数" id="uartputc関数">uartputc関数</a></h2>
<p>uartputc関数は、シリアルポートに文字を書き込む。</p>
<p>forループでUARTのラインステータスレジスタ（+5）のEmpty Transmitter Holding Register（5bit）が0になるまで、最大128回ループする。
5bitは1の場合は送信中、0の場合は送信可能。<br />
microdelay関数はlapic.cに定義されているが実体は何もしない。
コメントに、実際のハードウェアではマイクロ秒単位のスピンロックを動的に行うと書いてある。<br />
Transmitter Holding Buffer（+0, DLABは0）に引数の文字を書き込む。</p>
<p>uart.c</p>
<pre><code class="language-c">void
uartputc(int c)
{
  int i;

  if(!uart)
    return;
  for(i = 0; i &lt; 128 &amp;&amp; !(inb(COM1+5) &amp; 0x20); i++)
    microdelay(10);
  outb(COM1+0, c);
}
</code></pre>
<p>lapic.c</p>
<pre><code class="language-c">// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
void
microdelay(int us)
{
}
</code></pre>
<h1><a class="header" href="#514-pinit関数" id="514-pinit関数">5.14. pinit関数</a></h1>
<p>この関数はプロセステーブルのロックを初期化する。</p>
<p>コメントの通り。</p>
<p>param.h</p>
<pre><code class="language-c">#define NPROC        64  // maximum number of processes
</code></pre>
<p>proc.c</p>
<pre><code class="language-c">struct {
  struct spinlock lock;
  struct proc proc[NPROC];
} ptable;

/* 略 */

void
pinit(void)
{
  initlock(&amp;ptable.lock, &quot;ptable&quot;);
}
</code></pre>
<h2><a class="header" href="#proc構造体" id="proc構造体">proc構造体</a></h2>
<p>プロセスを表す構造体。
コメントの通り。</p>
<p>types.h</p>
<pre><code class="language-c">typedef uint pde_t;
</code></pre>
<p>param.h</p>
<pre><code class="language-c">#define NOFILE       16  // open files per process
</code></pre>
<p>proc.h</p>
<pre><code class="language-c">enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };

// Per-process state
struct proc {
  uint sz;                     // Size of process memory (bytes)
  pde_t* pgdir;                // Page table
  char *kstack;                // Bottom of kernel stack for this process
  enum procstate state;        // Process state
  int pid;                     // Process ID
  struct proc *parent;         // Parent process
  struct trapframe *tf;        // Trap frame for current syscall
  struct context *context;     // swtch() here to run process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
};
</code></pre>
<h1><a class="header" href="#515-tvinit関数" id="515-tvinit関数">5.15. tvinit関数</a></h1>
<p>大域変数idtに256個のゲートディスクリプタを作成する。</p>
<p>IDT（Interrupt Descriptor Table）を作成する。<br />
IDTについては<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」（リンク8）</a>のVol.3 Chapter6.10「Interrupt Descriptor Table (IDT)」で説明されている。
ここでは、IDTはgatedesc構造体の配列になっており、大域変数idtで宣言されている。
Intel SDMによると256個の割り込みベクタを持てるため、idtの要素数も256。</p>
<p>IDTに格納される各ゲートディスクリプタの構造はIntel SDMの図6-2「IDT Gate Descriptors」に記載されており、ここで使用するのはInterrupt GateとTrap Gate。
割り込みにはInterrupt Gateを使用し、システムコールにはTrap Gateを使用する。</p>
<p>gatedesc構造体はmmu.hで定義されている。</p>
<ul>
<li><strong>off_15_0:</strong> 割り込みベクタのアドレスの下半分を設定する。</li>
<li><strong>cs:</strong> GDT上のエントリのインデックスを設定する。
セグメントディスクリプタは8バイトなので8の倍数。</li>
<li><strong>args:</strong> 予約済みなので0埋め。</li>
<li><strong>rsv1:</strong> 全て0。</li>
<li><strong>type:</strong> Interrupt Gateの場合は0b1110（0xE）、Trap Gateの場合は0b1111（0xF）を設定する。
Intel SDMの図で確認すると3bitがDになり、ゲートディスクリプタのサイズが32bitの場合1、16bitの場合0になる。
なのでここでは1で固定。</li>
<li><strong>s:</strong> 12bitに当たるので0固定。</li>
<li><strong>dpl:</strong> ディスクリプタ特権レベル（Descriptor Privilege Level）なので、Interrupt Gateの場合0、Trap Gateの場合3を設定する。
特権レベルについてはVol.3 Chapter5.5「PRIVILEGE LEVELS」で説明されており、カーネルが0、ユーザが3。</li>
<li><strong>p:</strong> セグメント存在フラグ。今回はセグメントがメモリ上に存在するので1を設定する。</li>
<li><strong>off_31_16:</strong> 割り込みベクタのアドレスの上半分を設定する。</li>
</ul>
<p>SETGATEマクロで各ゲートディスクリプタを作成する。</p>
<p>trap.c</p>
<pre><code class="language-c">struct gatedesc idt[256];
</code></pre>
<p>mmu.h</p>
<pre><code class="language-c">struct gatedesc {
  uint off_15_0 : 16;   // low 16 bits of offset in segment
  uint cs : 16;         // code segment selector
  uint args : 5;        // # args, 0 for interrupt/trap gates
  uint rsv1 : 3;        // reserved(should be zero I guess)
  uint type : 4;        // type(STS_{IG32,TG32})
  uint s : 1;           // must be 0 (system)
  uint dpl : 2;         // descriptor(meaning new) privilege level
  uint p : 1;           // Present
  uint off_31_16 : 16;  // high bits of offset in segment
};

/* 略 */

#define SETGATE(gate, istrap, sel, off, d)                \
{                                                         \
  (gate).off_15_0 = (uint)(off) &amp; 0xffff;                \
  (gate).cs = (sel);                                      \
  (gate).args = 0;                                        \
  (gate).rsv1 = 0;                                        \
  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
  (gate).s = 0;                                           \
  (gate).dpl = (d);                                       \
  (gate).p = 1;                                           \
  (gate).off_31_16 = (uint)(off) &gt;&gt; 16;                  \
}
</code></pre>
<p>割り込みベクタテーブルはvectors.Sに定義されている256個の関数のアドレスが、同ファイル内のvectorsラベル以下に列挙されている。
関数はvector0からvector255まであり、スタックに0とIRQ番号をプッシュし、alltraps関数に跳んでいる。
alltraps関数はtrapasm.Sで定義されている。
vectors.Sは<a href="chapter_05//chapter_02/02_04_kernel.html">make時</a>にvectors.plを実行することで作られる。<br />
trap.cで、extern宣言として符号なし整数型の配列vectorsで割り込みベクタテーブルを参照している。</p>
<p>vectors.S</p>
<pre><code class="language-asm">.globl alltraps
.globl vector0
vector0:
  pushl $0
  pushl $0
  jmp alltraps
.globl vector1

# 略

.globl vector255
vector255:
  pushl $0
  pushl $255
  jmp alltraps

# vector table
.data
.globl vectors
vectors:
  .long vector0

# 略

  .long vector255
</code></pre>
<p>trap.c</p>
<pre><code class="language-c">extern uint vectors[];  // in vectors.S: array of 256 entry pointers
</code></pre>
<p>tvinit関数では、まずforループで配列idtに割り込みベクタテーブルの全エントリ分（256個）の割り込みゲートディスクリプタを作成する。
DPLは0。<br />
次に、システムコールにはIRQ64番を使うので、idtの64番目を上書きする形でトラップゲートディスクリプタをDPL3で作成する。<br />
最後にtickslockのロックを初期化する。</p>
<p>trap.c</p>
<pre><code class="language-c">void
tvinit(void)
{
  int i;

  for(i = 0; i &lt; 256; i++)
    SETGATE(idt[i], 0, SEG_KCODE&lt;&lt;3, vectors[i], 0);
  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE&lt;&lt;3, vectors[T_SYSCALL], DPL_USER);

  initlock(&amp;tickslock, &quot;time&quot;);
}
</code></pre>
<h2><a class="header" href="#tick" id="tick">tick</a></h2>
<p>tickは一般的に一定周期で時間を刻むことを言い、ここでも同様に使われる。</p>
<p>符号なしint型の大域変数ticksと、そのロックに使用するtickslockが定義されている。
使用箇所をgrepすると、タイマー割り込みに関する部分とシステムコールsys_sleep内でのみ使用されており、インクリメントだけで代入は行われない。<br />
sysproc.cに定義されているsys_sleep関数でその使われ方を見ることができる。
この関数はticksが引数n分だけインクリメントされるまで、現在のプロセスをスリープ状態にする。<br />
はじめに、argint関数を使用して自身に与えられたint型の引数を変数nに取り出す。<br />
そして現在のticksの値をローカル変数ticks0に保存しておく。<br />
whileループで <code>ticks - ticks0 &lt; n</code> が偽になるまでプロセスをスリープする。
起床するためのチャネルにはticksのアドレスを用いる。<br />
ticksはcpu0からのタイマー割り込みによりインクリメントされるので、その度に起床されることになる。</p>
<p>trap.c</p>
<pre><code class="language-c">struct spinlock tickslock;
uint ticks;
</code></pre>
<p>sysproc.c</p>
<pre><code class="language-c">int
sys_sleep(void)
{
  int n;
  uint ticks0;

  if(argint(0, &amp;n) &lt; 0)
    return -1;
  acquire(&amp;tickslock);
  ticks0 = ticks;
  while(ticks - ticks0 &lt; n){
    if(myproc()-&gt;killed){
      release(&amp;tickslock);
      return -1;
    }
    sleep(&amp;ticks, &amp;tickslock);
  }
  release(&amp;tickslock);
  return 0;
}
</code></pre>
<p>ticksがインクリメントされる部分だけ合わせて見ることにする。<br />
割り込みやトラップが生じるとIDTや割り込みベクタテーブル等を経由してtrapasm.Sのalltraps関数からtrap.cのtrap関数が呼び出されれる。<br />
trap関数はIRQ番号によって分岐する。<br />
ticksはタイマー割り込みかつcpu0からの割り込みである場合にのみインクリメントされる。<br />
その後ticksのアドレスをチャネルとしてスリープ状態のプロセスを起床させる。<br />
LAPICタイマの設定は<a href="chapter_05//chapter_05/05_05_lapicinit.html#LAPIC%E3%82%BF%E3%82%A4%E3%83%9E%E3%81%AE%E8%A8%AD%E5%AE%9A">lapicinit</a>で見た。</p>
<p>trap.c</p>
<pre><code class="language-c">  switch(tf-&gt;trapno){
  case T_IRQ0 + IRQ_TIMER:
    if(cpuid() == 0){
      acquire(&amp;tickslock);
      ticks++;
      wakeup(&amp;ticks);
      release(&amp;tickslock);
    }
    lapiceoi();
    break;
</code></pre>
<h1><a class="header" href="#516-binit関数" id="516-binit関数">5.16. binit関数</a></h1>
<p>この関数でバッファキャッシュを初期化を行う。</p>
<p>バッファキャッシュについては<a href="chapter_05//chapter_05/05_12_bcache.html">5.12. バッファキャッシュとディスクの読み書き</a>で見た。<br />
キャッシュを走査するためのbcache内のheadフィールドの前（prev）と後（next）のアドレスをheadフィールドの値で初期化する。<br />
そしてforループでバッファキャッシュの全エントリ（30個）を初期化し、buf配列が循環するようにリンクさせる。
ループが終わると、headのnextはbuf配列の29番目を指すようになり、prevは0番目を指すようになる。
29番目のprevと0番目のnextはheadを指す。<br />
headからnextを辿ると、buf配列の29, 28, 27 ... 0, headとなる。<br />
headからprevを辿ると、buf配列の0, 1, 2 ... 29, headとなる。</p>
<p>bio.c</p>
<pre><code class="language-c">void
binit(void)
{
  struct buf *b;

  initlock(&amp;bcache.lock, &quot;bcache&quot;);

//PAGEBREAK!
  // Create linked list of buffers
  bcache.head.prev = &amp;bcache.head;
  bcache.head.next = &amp;bcache.head;
  for(b = bcache.buf; b &lt; bcache.buf+NBUF; b++){
    b-&gt;next = bcache.head.next;
    b-&gt;prev = &amp;bcache.head;
    initsleeplock(&amp;b-&gt;lock, &quot;buffer&quot;);
    bcache.head.next-&gt;prev = b;
    bcache.head.next = b;
  }
}
</code></pre>
<h1><a class="header" href="#517-fileinit関数" id="517-fileinit関数">5.17. fileinit関数</a></h1>
<p>この関数はファイルテーブル構造体のロックを初期化する。</p>
<p>ファイルテーブル構造体は大域変数ftableとして定義されており、fileフィールドにはオープンしているファイルを持つ。
要素数100なのでオープンできるのは最大100ファイル。</p>
<p>param.h</p>
<pre><code class="language-c">#define NFILE       100  // open files per system
</code></pre>
<p>file.c</p>
<pre><code class="language-c">struct {
  struct spinlock lock;
  struct file file[NFILE];
} ftable;

void
fileinit(void)
{
  initlock(&amp;ftable.lock, &quot;ftable&quot;);
}
</code></pre>
<h2><a class="header" href="#file構造体" id="file構造体">file構造体</a></h2>
<p>各フィールドは名前の通り。<br />
タイプに合わせてpipeフィールドかinodeフィールドに各構造体を持つ。<br />
iノードの場合はoffフィールドにファイル内でのオフセットを持つ。</p>
<p>file.h</p>
<pre><code class="language-c">struct file {
  enum { FD_NONE, FD_PIPE, FD_INODE } type;
  int ref; // reference count
  char readable;
  char writable;
  struct pipe *pipe;
  struct inode *ip;
  uint off;
};
</code></pre>
<h2><a class="header" href="#pipe構造体" id="pipe構造体">pipe構造体</a></h2>
<p>dataフィールドはパイプで流すデータを保持する。<br />
他のフィールドはコメントの通り。</p>
<p>data, nread, nwriteフィールドは、<a href="chapter_05//chapter_05/05_09_consoleinit.html#consoleintr%E9%96%A2%E6%95%B0">consoleintr関数とconsoleread関数</a>で使用されるinput構造体のbuf, r, wフィールドと同様の使い方をする。
つまりnreadとnwriteは増加し続け、dataにはnreadとnwriteをPIPESIZEで割った余りをインデックスとしてアクセスする。</p>
<p>pipe.c</p>
<pre><code class="language-c">#define PIPESIZE 512

struct pipe {
  struct spinlock lock;
  char data[PIPESIZE];
  uint nread;     // number of bytes read
  uint nwrite;    // number of bytes written
  int readopen;   // read fd is still open
  int writeopen;  // write fd is still open
};
</code></pre>
<h1><a class="header" href="#518-ideinit関数" id="518-ideinit関数">5.18. ideinit関数</a></h1>
<p>この関数ではIDEの割り込みの有効化と、ディスク1の存在確認を行う。</p>
<p>ide.cに宣言されている静的なint型の変数havedisk1が、ディスク1の有無を示すフラグとなっており、値が1場合にディスク1があることを示す。</p>
<p>IDEからの割り込みを<a href="chapter_05//chapter_05/05_09_consoleinit.html#ioapicenable%E9%96%A2%E6%95%B0">ioapicenable関数</a>で有効化する。
IRQ番号は<a href="https://wiki.osdev.org/Interrupts">「OSDev Interrupt」（リンク29）</a>の表「Standard ISA IRQs」をによると、14番がPrimary ATA Hard Disk、と15番がSecondary ATA Hard Diskとなっている。
ここでは14番（IRQ_IDE）からの割り込みを有効化する。
割り込み先はcpuid（LAPIC ID）が最も大きいcpuに設定する。
cpu数を示す大域変数ncpuは<a href="chapter_05//chapter_05/05_04_mpinit.html">mpinit関数</a>で設定した。</p>
<p><a href="chapter_05//chapter_05/05_12_bcache.html#%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%81%AE%E8%AA%AD%E3%81%BF%E6%9B%B8%E3%81%8Diderw%E9%96%A2%E6%95%B0">idewait関数</a>でディスク0がビジーでもエラーでもなくなるまで待つ。<br />
ディスク1の有無を確認するために、読み書きを行うディスクをディスク1に切り替える。
<a href="https://wiki.osdev.org/ATA_PIO_Mode">「OSDev ATA PIO Mode」（リンク23）</a>によると、IDEコントローラのdrive/headレジスタ（0x1f6）の4bitを1にすることでディスク1に切り替えられる。
また、5～7bitは101で固定のようだが、ここでは0xe0で全て1に設定している。<br />
ディスク1のステータスレジスタ（0x1f7）から0以外の値が読み取れるまで、for文で1000回ループする。
エラーになっていようがレディになっていようがとりあえず0以外が返ってくればディスク1が存在することは確認できる。<br />
ディスク1の存在確認完了後、読み書きするディスクをディスク0に戻す。</p>
<p>traps.h</p>
<pre><code class="language-c">#define IRQ_IDE         14
</code></pre>
<p>ide.c</p>
<pre><code class="language-c">static int havedisk1;

/* 略 */

void
ideinit(void)
{
  int i;

  initlock(&amp;idelock, &quot;ide&quot;);
  ioapicenable(IRQ_IDE, ncpu - 1);
  idewait(0);

  // Check if disk 1 is present
  outb(0x1f6, 0xe0 | (1&lt;&lt;4));
  for(i=0; i&lt;1000; i++){
    if(inb(0x1f7) != 0){
      havedisk1 = 1;
      break;
    }
  }

  // Switch back to disk 0.
  outb(0x1f6, 0xe0 | (0&lt;&lt;4));
}
</code></pre>
<h1><a class="header" href="#519-startothers関数" id="519-startothers関数">5.19. startothers関数</a></h1>
<p>各APを起動し、GDT、ページング、IDT等の設定を行い、スケジューラを実行する。</p>
<p>APをスタートさせ、設定を済ませて一気にスケジューラの起動まで行う。
なのでmain関数の最後に呼ばれるmpmain関数もここで先に呼ばれる。
APで行う設定はほとんどBSPと同じように行う。</p>
<p>startothers関数を見る前に、APのエントリポイントとなるentryother.Sを見る。<br />
Makefileのターゲットentryotherを見ると、まずgccでentryother.Sからentryother.oを作成する。</p>
<p>各コマンドのオプションについては<a href="chapter_05//chapter_02/02_00_xv6_img_build.html">「2. xv6.imgのビルド」</a>で見た。<br />
ldのTtextオプションでTEXTセグメントの開始アドレスを0x7000とし、entryother.oからbootblockother.oを作成する。
objcopyでbootblockother.oからTEXTセクションのみをentryotherとしてコピーする。
出力にバイナリを指定しているため、entryotherに次の3つのシンボルが作成される。</p>
<ul>
<li>_binary_entryother_start</li>
<li>_binary_entryother_end</li>
<li>_binary_entryother_size</li>
</ul>
<p>最後にobjdumpでbootblockother.oを逆アセンブルし、entryother.asmを作成している。
カーネルには作成したバイナリのentryotherがリンクされる。</p>
<p>Makefile</p>
<pre><code class="language-makefile">entryother: entryother.S
  $(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
  $(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
  $(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
  $(OBJDUMP) -S bootblockother.o &gt; entryother.asm
</code></pre>
<p><a href="chapter_05//chapter_05/05_09_consoleinit.html#memmove%E9%96%A2%E6%95%B0">memmove関数</a>を使用してentryother.Sのコードを物理アドレス0x7000にコピーする。
APではページングがまだ有効化されていないので、P2Vマクロを使用して仮想アドレスを求める必要がある。</p>
<p>forループで<a href="chapter_05//chapter_05/05_04_mpinit.html">大域変数cpus</a>を走査し、APをひとつずつ起動する。
BSPの場合はcontinue。
このループはBSPで実行されているため、mycpu関数はBSPのcpu構造体を返す。</p>
<p>APの起動時に使用するカーネルスタックとして変数stackに1ページ分のメモリを割り当てる。
割り当てには<a href="chapter_05//chapter_05/05_03_kvmalloc.html#kalloc%E9%96%A2%E6%95%B0">kalloc関数</a>を用いる。
大域変数kmemのuse_lockフィールドは依然として0なので排他制御は行わない（kinit2関数で初めて1になる）。</p>
<p>entryotherを実行する際に渡す引数をスタックにセットする。</p>
<ul>
<li><strong>第一引数:</strong> スタックの底のアドレス。
スタックのアドレスにカーネルスタックサイズ（4kB）を加算して求める。</li>
<li><strong>第二引数:</strong> main.cに定義されているmpenter関数のアドレス。関数ポインタとしてキャストして代入する。</li>
<li><strong>第三引数:</strong> main.cに定義されている<a href="chapter_05//chapter_04/04_01_entry.html">変数entrypgdir</a>のアドレス。
ラージページのページディレクトリで、0番と512番の2つのエントリが0ページ目（物理アドレス0から4MB分）を指している。</li>
</ul>
<p>BSPはAPのcpu構造体のstartedフィールドが0でなくなるまでwhileループする。
startedフィールドが1になるまでの大まかな流れは次の通り。</p>
<ol>
<li>lapicstartap関数でAPを起動</li>
<li>codeとして渡したentryother.Sの実行</li>
<li>entryother.Sに第二引数として渡したmpenter関数の実行</li>
<li>mpmain関数でAPのcpu構造体のstartedフィールドに1を設定</li>
</ol>
<p>main.c</p>
<pre><code class="language-c">static void
startothers(void)
{
  extern uchar _binary_entryother_start[], _binary_entryother_size[];
  uchar *code;
  struct cpu *c;
  char *stack;

  // Write entry code to unused memory at 0x7000.
  // The linker has placed the image of entryother.S in
  // _binary_entryother_start.
  code = P2V(0x7000);
  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);

  for(c = cpus; c &lt; cpus+ncpu; c++){
    if(c == mycpu())  // We've started already.
      continue;

    // Tell entryother.S what stack to use, where to enter, and what
    // pgdir to use. We cannot use kpgdir yet, because the AP processor
    // is running in low  memory, so we use entrypgdir for the APs too.
    stack = kalloc();
    *(void**)(code-4) = stack + KSTACKSIZE;
    *(void(**)(void))(code-8) = mpenter;
    *(int**)(code-12) = (void *) V2P(entrypgdir);

    lapicstartap(c-&gt;apicid, V2P(code));

    // wait for cpu to finish mpmain()
    while(c-&gt;started == 0)
      ;
  }
}

/* 略 */

__attribute__((__aligned__(PGSIZE)))
pde_t entrypgdir[NPDENTRIES] = {
  // Map VA's [0, 4MB) to PA's [0, 4MB)
  [0] = (0) | PTE_P | PTE_W | PTE_PS,
  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
  [KERNBASE&gt;&gt;PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
};
</code></pre>
<h2><a class="header" href="#lapicstartap関数" id="lapicstartap関数">lapicstartap関数</a></h2>
<p>この関数ではAPを起動し、entryother.Sを実行する。</p>
<p>APの起動方法は<a href="https://pdos.csail.mit.edu/6.828/2008/readings/ia32/MPspec.pdf">「MultiProcessor Specification Version 1.4」（リンク14）</a>のB.4「Application Processor Startup」に記載されている。<br />
起動の流れは次のようになる。</p>
<ol>
<li>BSPのBIOSシャットダウンコードを0x0Aに初期化し、warm reset vectorにAPリセット時に実行させるコードのアドレスを設定する。
BIOSシャットダウンコード（0x0A）は、リセット時にBIOSの初期化処理を行わず、EOI（End Of Interrupt割り込み終了の信号）なしで40:67（CS:IP）に格納されている4バイトのアドレスにジャンプする。</li>
<li>BSPから起動したいAPにINIT IPIを送る。</li>
<li>IPIの処理が終わるまで10ms待つ。</li>
<li>BSPから起動したいAPにSTARTUP IPIを送る。このとき、Vectorフィールドに実行開始アドレスを入れる。</li>
<li>IPIの処理が終わるまで200μs待つ。</li>
<li>手順4と5をもう一度行う。INIT IPIとSTARTUP IPIは自動で再試行せず、OSはそれを正常に行う必要があるため2回呼び出す。
lapicstartap関数のコメントによると、2回目のSTARTUP IPIでのみAPを起動させるアーキテクチャも存在するらしい。</li>
</ol>
<p>INIT IPIの使用方法は<a href="chapter_05//chapter_05/05_05_lapicinit.html#icr%E3%81%AE%E8%A8%AD%E5%AE%9A">lapicinit関数</a>で見た。<br />
STARTUP IPIの使用方法は「MultiProcessor Specification Version 1.4」（リンク14）のB.4.2「USING STARTUP IPI」に記載されている。
このIPIは送信先のプロセッサをリアルモードで物理アドレス0x000VV000から実行する。
VVの部分は、ICRのVectorフィールドに設定された値が入る。</p>
<p>起動手順をlapicstartap関数に沿って読んでいく。
完全に上記手順に従っているわけではないため、行っていることがやや異なる。</p>
<p><strong>手順1:</strong><br />
BIOSのシャットダウンコードを0x0Aに初期化する。<br />
BIOSの設定を行うCMOSのポートは<a href="http://bochs.sourceforge.net/doc/docbook/development/index.html">「Bochs Developers Guide」（リンク9）</a>によると、0x70～0x7Fであり0x70がCMOSのインデックスレジスタとなっている。
シャットダウンコードの設定はシャットダウンステータスバイト（0x0F）から行うことができ、0x0Aの場合は、リセット時に40:67（CS:IP）に格納されている4バイトのアドレスにジャンプする設定となる。<br />
リセット時にentryother.Sが実行されるよう、物理アドレス0x467にcode（引数addr）のアドレスを代入する。
リアルモードのセグメント機構ではセグメントレジスタが16bit、アドレスバスが20bitであるため、セグメントのアクセスではアドレスの下位4bitを0とする。
そのため0x7000（entryotherの開始アドレス）を4bit右シフトしている。
この辺りのことは<a href="chapter_05//ref_books.html">「初めて読む486」（書籍2）</a>に書いてある。</p>
<p><strong>手順2:</strong><br />
APにINIT IPIを2回送る。<br />
INIT IPIはlapicinit関数で使用したが、ここではLevelがAssertになっているため、もう一度見る。<br />
IPIについては<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」（リンク8）</a>のVol.3A「10.6.1 Interrupt Command Register (ICR)」に記載されている。</p>
<p>1回目:<br />
LAPICのICR（Interrupt Command Register）（LAPICのインデックス0x310）に書き込みを行うことでIPIを送信する。
上半分（56bit目）にLAPIC IDを設定し、下半分にはINIT（0x500）、LEVEL（0x8000）、ASSERT（0x4000）を設定する（0b1100 0101 0000 0000）。<br />
8～10bitが0b101なので、Delivery ModeはINIT。<br />
11bitが0なのでDestination ModeはPhysical。<br />
14bitが1なのでLevelはAssert。<br />
15bitが1なのでTrigger ModeはLevel。<br />
Levelフラグが1（Assert）かつ、Delivery ModeのINITがLevel De-assertでないことから、INITリクエストを特定のプロセッサに送信することがわかる。
送信先はDestination ModeがPhysicalであることから、ICRの56～59bitで指定されたLAPICIDのプロセッサとなる。</p>
<p>INIT IPIの処理が終わるまで200μs待つ（<a href="chapter_05//chapter_05/05_13_uartinit.html#uartputc%E9%96%A2%E6%95%B0">microdelay関数</a>）。</p>
<p>2回目:<br />
Levelフラグを0（De-assert）でINIT IPIを送信する。
Delivery ModeがDe-assertなので送信先は全てのプロセッサとなる。</p>
<p><strong>手順3:</strong><br />
100μs待つ。<br />
「MultiProcessor Specification Version 1.4」（リンク14）には10msとあるが、lapicstartap関数のコメントにBochsでは遅すぎると記載がある。</p>
<p><strong>手順4:</strong><br />
STARTUP IPIを2回送る。<br />
ICRの56～59bitに送信先APのLAPIC IDを設定し、8～10bit目に0b110（Start-Up）を設定して、Vectorにentryother.Sのアドレス（0x7）を設定（実行を開始するアドレスVVの部分）する。</p>
<p><strong>手順5:</strong><br />
200μs待つ。</p>
<p>関数内のAP起動手順は以上。
第一引数apicidで指定されたAPはSTARTUP IPIで起動され、entryother.Sが実行される。</p>
<p>lapic.c</p>
<pre><code class="language-c">#define ICRLO   (0x0300/4)   // Interrupt Command
  #define INIT       0x00000500   // INIT/RESET
  #define STARTUP    0x00000600   // Startup IPI
  #define DELIVS     0x00001000   // Delivery status
  #define ASSERT     0x00004000   // Assert interrupt (vs deassert)
  #define DEASSERT   0x00000000
  #define LEVEL      0x00008000   // Level triggered
  #define BCAST      0x00080000   // Send to all APICs, including self.
  #define BUSY       0x00001000
  #define FIXED      0x00000000
#define ICRHI   (0x0310/4)   // Interrupt Command [63:32]

/* 略 */

#define CMOS_PORT    0x70
#define CMOS_RETURN  0x71

/* 略 */

void
lapicstartap(uchar apicid, uint addr)
{
  int i;
  ushort *wrv;

  // &quot;The BSP must initialize CMOS shutdown code to 0AH
  // and the warm reset vector (DWORD based at 40:67) to point at
  // the AP startup code prior to the [universal startup algorithm].&quot;
  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
  outb(CMOS_PORT+1, 0x0A);
  wrv = (ushort*)P2V((0x40&lt;&lt;4 | 0x67));  // Warm reset vector
  wrv[0] = 0;
  wrv[1] = addr &gt;&gt; 4;

  // &quot;Universal startup algorithm.&quot;
  // Send INIT (level-triggered) interrupt to reset other CPU.
  lapicw(ICRHI, apicid&lt;&lt;24);
  lapicw(ICRLO, INIT | LEVEL | ASSERT);
  microdelay(200);
  lapicw(ICRLO, INIT | LEVEL);
  microdelay(100);    // should be 10ms, but too slow in Bochs!

  // Send startup IPI (twice!) to enter code.
  // Regular hardware is supposed to only accept a STARTUP
  // when it is in the halted state due to an INIT.  So the second
  // should be ignored, but it is part of the official Intel algorithm.
  // Bochs complains about the second one.  Too bad for Bochs.
  for(i = 0; i &lt; 2; i++){
    lapicw(ICRHI, apicid&lt;&lt;24);
    lapicw(ICRLO, STARTUP | (addr&gt;&gt;12));
    microdelay(200);
  }
}
</code></pre>
<h2><a class="header" href="#entryothers" id="entryothers">entryother.S</a></h2>
<p>この関数はSTARTUP IPIによりAPで実行される。<br />
概ね<a href="chapter_05//chapter_03/03_01_bootasm.html">bootasm.S</a>、<a href="chapter_05//chapter_04/04_01_entry.html">entry.S</a>と同様。<br />
GDTをロードし、プロテクトモードへ移行、ページングを有効化する。<br />
最後にスタックポインタをセットし、mpenter関数を呼び出す。</p>
<p>ラージページの設定まではbootasm.Sとentry.Sのコードと同じ。<br />
ページディレクトリの設定から見る。<br />
entryother.Sはobjcopyコマンドで作成されたバイナリとしてリンクされているため、main.cで定義されているentrypgdir変数が見えない。
そのため、startothers関数内であらかじめ第3引数の位置（start-12）にセットしておいたentrypgdirのアドレスを使用する。<br />
同様に、スタックポインタに設定するスタックのアドレスはstartothers関数にてkalloc関数で割り当てた1ページ分の領域を設定する。
これは第一引数の位置にセットしたので、 start-4 になる。<br />
最後にmpenter関数のアドレスは、startothers関数で第二引数の位置にセットしたので、start-8 になる。</p>
<p>entryother.S</p>
<pre><code class="language-asm">.code16           
.globl start
start:
  cli            

  # Zero data segment registers DS, ES, and SS.
  xorw    %ax,%ax
  movw    %ax,%ds
  movw    %ax,%es
  movw    %ax,%ss

  # Switch from real to protected mode.  Use a bootstrap GDT that makes
  # virtual addresses map directly to physical addresses so that the
  # effective memory map doesn't change during the transition.
  lgdt    gdtdesc
  movl    %cr0, %eax
  orl     $CR0_PE, %eax
  movl    %eax, %cr0

  # Complete the transition to 32-bit protected mode by using a long jmp
  # to reload %cs and %eip.  The segment descriptors are set up with no
  # translation, so that the mapping is still the identity mapping.
  ljmpl    $(SEG_KCODE&lt;&lt;3), $(start32)

//PAGEBREAK!
.code32  # Tell assembler to generate 32-bit code now.
start32:
  # Set up the protected-mode data segment registers
  movw    $(SEG_KDATA&lt;&lt;3), %ax    # Our data segment selector
  movw    %ax, %ds                # -&gt; DS: Data Segment
  movw    %ax, %es                # -&gt; ES: Extra Segment
  movw    %ax, %ss                # -&gt; SS: Stack Segment
  movw    $0, %ax                 # Zero segments not ready for use
  movw    %ax, %fs                # -&gt; FS
  movw    %ax, %gs                # -&gt; GS

  # Turn on page size extension for 4Mbyte pages
  movl    %cr4, %eax
  orl     $(CR4_PSE), %eax
  movl    %eax, %cr4
  # Use entrypgdir as our initial page table
  movl    (start-12), %eax
  movl    %eax, %cr3
  # Turn on paging.
  movl    %cr0, %eax
  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  movl    %eax, %cr0

  # Switch to the stack allocated by startothers()
  movl    (start-4), %esp
  # Call mpenter()
  call	 *(start-8)

  movw    $0x8a00, %ax
  movw    %ax, %dx
  outw    %ax, %dx
  movw    $0x8ae0, %ax
  outw    %ax, %dx
spin:
  jmp     spin

.p2align 2
gdt:
  SEG_NULLASM
  SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
  SEG_ASM(STA_W, 0, 0xffffffff)


gdtdesc:
  .word   (gdtdesc - gdt - 1)
  .long   gdt
</code></pre>
<h2><a class="header" href="#mpenter関数" id="mpenter関数">mpenter関数</a></h2>
<p>BSPで行った設定を同様にAPにも行う。<br />
<a href="chapter_05//chapter_05/05_03_kvmalloc.html#switchkvm%E9%96%A2%E6%95%B0">switchkvm関数</a>でcr3にカーネル用のページディレクトリkpgdirのアドレスをセットする。
kpgdirはBSPと同じものが使用される。
<a href="chapter_05//chapter_05/05_03_kvmalloc.html#walkpgdir%E9%96%A2%E6%95%B0">4kBページングとなる</a>のも同様。<br />
<a href="chapter_05//chapter_05/05_06_seginit.html">seginit関数</a>でGDTの作成とロード、<a href="chapter_05//chapter_05/05_05_lapicinit.html">lapicinit関数</a>でLAPICの設定を行う。</p>
<p>main.c</p>
<pre><code class="language-c">static void
mpenter(void)
{
  switchkvm();
  seginit();
  lapicinit();
  mpmain();
}
</code></pre>
<h2><a class="header" href="#mpmain関数" id="mpmain関数">mpmain関数</a></h2>
<p>この関数はコンソールに「cpu1: starting 1」と表示し、IDTをロードしてcpu構造体のstartedフィールドの値を1にした後、スケジューラを呼び出す。
コンソールの文字列はLAPIC IDによって変わる。<br />
cpu構造体のstartedフィールドを<a href="chapter_05//chapter_05/05_10_lock.html#xchg%E9%96%A2%E6%95%B0">xchg関数</a>で1にする。
ここでxchg命令を使ってアトミックにstartedフィールドの値を更新する理由はわからない。<br />
この関数はBSPからmain関数の最後でも呼び出される。
scheduler関数はその時に見ることにする。</p>
<p>main.c</p>
<pre><code class="language-c">static void
mpmain(void)
{
  cprintf(&quot;cpu%d: starting %d\n&quot;, cpuid(), cpuid());
  idtinit();       // load idt register
  xchg(&amp;(mycpu()-&gt;started), 1); // tell startothers() we're up
  scheduler();     // start running processes
}
</code></pre>
<h2><a class="header" href="#cprintf関数" id="cprintf関数">cprintf関数</a></h2>
<p>この関数は与えられたフォーマットでコンソールに文字を出力する。
フォーマットにはエスケープシーケンスを使用することが可能であり、第二引数以降の可変個の文字をフォーマットして挿入できる。</p>
<p>変数argpに可変長引数の先頭アドレスを代入する。
第一引数fmtのアドレスをuint分加算し、スタックの低い位置（高いアドレス）に有る第二引数を得る。<br />
fmtを1バイトずつ操作し、場合分けしながらコンソールに出力する。</p>
<ul>
<li><strong>%以外:</strong> <a href="chapter_05//chapter_05/05_09_consoleinit.html#consolewrite%E9%96%A2%E6%95%B0">consputc関数</a>でコンソールに出力する。</li>
<li><strong>0:</strong> ループをbreak。</li>
<li><strong>d:</strong> printint関数で可変長引数から10進数符号ありでコンソールに出力する。</li>
<li><strong>x, p:</strong> printint関数で可変長引数から16進数符号なしでコンソールに出力する。</li>
<li><strong>s:</strong> 可変長引数から文字列を出力する。
1文字ずつ取り出し、値が0になるまでconsputc関数で1バイトずつコンソールに出力する。
1文字目が0の場合のみ文字列 &quot;(null)&quot; を出力する。</li>
<li><strong>%:</strong> consputc関数でコンソールに '%' を出力する。</li>
</ul>
<p>console.c</p>
<pre><code class="language-c">void
cprintf(char *fmt, ...)
{
  int i, c, locking;
  uint *argp;
  char *s;

  locking = cons.locking;
  if(locking)
    acquire(&amp;cons.lock);

  if (fmt == 0)
    panic(&quot;null fmt&quot;);

  argp = (uint*)(void*)(&amp;fmt + 1);
  for(i = 0; (c = fmt[i] &amp; 0xff) != 0; i++){
    if(c != '%'){
      consputc(c);
      continue;
    }
    c = fmt[++i] &amp; 0xff;
    if(c == 0)
      break;
    switch(c){
    case 'd':
      printint(*argp++, 10, 1);
      break;
    case 'x':
    case 'p':
      printint(*argp++, 16, 0);
      break;
    case 's':
      if((s = (char*)*argp++) == 0)
        s = &quot;(null)&quot;;
      for(; *s; s++)
        consputc(*s);
      break;
    case '%':
      consputc('%');
      break;
    default:
      // Print unknown % sequence to draw attention.
      consputc('%');
      consputc(c);
      break;
    }
  }

  if(locking)
    release(&amp;cons.lock);
}
</code></pre>
<h2><a class="header" href="#printint関数" id="printint関数">printint関数</a></h2>
<p>この関数は整数xxを、基数baseとしてコンソールに出力する。
また、第三引数signが0以外の場合符号ありで出力する。</p>
<p>配列digitsを使用して整数xxを文字コードに変換し、配列bufに持つ。
bufは頭から詰めていき、お尻から出力する。</p>
<p>console.c</p>
<pre><code class="language-c">static void
printint(int xx, int base, int sign)
{
  static char digits[] = &quot;0123456789abcdef&quot;;
  char buf[16];
  int i;
  uint x;

  if(sign &amp;&amp; (sign = xx &lt; 0))
    x = -xx;
  else
    x = xx;

  i = 0;
  do{
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);

  if(sign)
    buf[i++] = '-';

  while(--i &gt;= 0)
    consputc(buf[i]);
}
</code></pre>
<h2><a class="header" href="#idtinit関数" id="idtinit関数">idtinit関数</a></h2>
<p>この関数は<a href="chapter_05//chapter_05/05_15_tvinit.html">tvinit関数</a>で作成したIDTをlidt関数を通してlidt命令でロードする。</p>
<p>trap.c</p>
<pre><code class="language-c">void
idtinit(void)
{
  lidt(idt, sizeof(idt));
}
</code></pre>
<p>x86.h</p>
<pre><code class="language-asm">struct gatedesc;

static inline void
lidt(struct gatedesc *p, int size)
{
  volatile ushort pd[3];

  pd[0] = size-1;
  pd[1] = (uint)p;
  pd[2] = (uint)p &gt;&gt; 16;

  asm volatile(&quot;lidt (%0)&quot; : : &quot;r&quot; (pd));
}
</code></pre>
<h1><a class="header" href="#520-kinit2関数" id="520-kinit2関数">5.20. kinit2関数</a></h1>
<p><a href="chapter_05//chapter_05/05_02_kinit1.html#freerange%E9%96%A2%E6%95%B0">freerange関数</a>で<a href="chapter_05//chapter_05/05_02_kinit1.html">kmem構造体</a>のfreelistに0x400000～0xe000000までの領域をページとして加える。
差を取ると0xdc00000で4096で割ると56320ページ分ある。</p>
<p>main.c</p>
<pre><code class="language-c">int
main(void)
{

/* 略 */

  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()

/* 略 */

}
</code></pre>
<p>kalloc.c</p>
<pre><code class="language-c">void
kinit2(void *vstart, void *vend)
{
  freerange(vstart, vend);
  kmem.use_lock = 1;
}
</code></pre>
<h1><a class="header" href="#521-userinit関数" id="521-userinit関数">5.21. userinit関数</a></h1>
<p>initcode.Sのプロセスを作成し、プロセステーブルに追加する。</p>
<p>userinit関数を見る前に、initプロセスを実行するinitcode.Sと、プロセステーブルのエントリをプロセスとして割り当てるallocproc関数を見る。</p>
<h2><a class="header" href="#initcodes" id="initcodes">initcode.S</a></h2>
<p><a href="chapter_05//chapter_05/05_19_startothers.html">entryother.S</a>と同様。
TEXTセグメントの開始アドレスは0x0。
以下のシンボルが作成され、バイナリがカーネルにリンクされる。</p>
<ul>
<li>_binary_initcode_start</li>
<li>_binary_initcode_end</li>
<li>_binary_initcode_size</li>
</ul>
<p>Makefile</p>
<pre><code class="language-makefile">initcode: initcode.S
  $(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
  $(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
  $(OBJCOPY) -S -O binary initcode.out initcode
  $(OBJDUMP) -S initcode.o &gt; initcode.asm
</code></pre>
<h2><a class="header" href="#allocproc関数" id="allocproc関数">allocproc関数</a></h2>
<p>この関数はプロセステーブルから未使用のエントリを取得し、初期化して返す。</p>
<p><a href="chapter_05//chapter_05/05_14_pinit.html">プロセステーブル</a>を走査し、stateフィールドがUNUSEDのエントリを取得してfoundラベルにジャンプする。</p>
<p>foundラベル以降ではproc構造体の各フィールドと、カーネルスタックを初期化する。<br />
<a href="chapter_05//chapter_05/05_03_kvmalloc.html#kalloc%E9%96%A2%E6%95%B0">kalloc関数</a>で1ページ分のをカーネルスタックとして割り当てる。
カーネルスタックの底（p-&gt;state + KSTACKSIZE）から順に以下3つを設定する。</p>
<ul>
<li>プロセスの状態を保存するために使用するトラップフレームの領域を確保する。</li>
<li>4バイト分の領域を確保し、trapret関数のアドレスを代入する。
カーネル空間での処理終了後、trapret関数を呼び出してトラップフレームに保存した状態を復元し、最終的にiret命令でユーザ空間に戻る。</li>
<li>contextフィール分の領域を確保し、0埋めする。
context構造体のeipフィールドにforkret関数のアドレスを代入する。</li>
</ul>
<p>プロセスは最初のコンテキストスイッチ時にforkret関数の実行から始まり、次にtrapret関数が実行され、トラップフレームに保存した状態を復元してユーザ空間でプログラムを実行することになる。</p>
<p>forkret関数とtrapret関数についてはinitプロセスで見る。</p>
<p>proc.h</p>
<pre><code class="language-c">enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
</code></pre>
<p>proc.c</p>
<pre><code class="language-c">static struct proc*
allocproc(void)
{
  struct proc *p;
  char *sp;

  acquire(&amp;ptable.lock);

  for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)
    if(p-&gt;state == UNUSED)
      goto found;

  release(&amp;ptable.lock);
  return 0;

found:
  p-&gt;state = EMBRYO;
  p-&gt;pid = nextpid++;

  release(&amp;ptable.lock);

  // Allocate kernel stack.
  if((p-&gt;kstack = kalloc()) == 0){
    p-&gt;state = UNUSED;
    return 0;
  }
  sp = p-&gt;kstack + KSTACKSIZE;

  // Leave room for trap frame.
  sp -= sizeof *p-&gt;tf;
  p-&gt;tf = (struct trapframe*)sp;

  // Set up new context to start executing at forkret,
  // which returns to trapret.
  sp -= 4;
  *(uint*)sp = (uint)trapret;

  sp -= sizeof *p-&gt;context;
  p-&gt;context = (struct context*)sp;
  memset(p-&gt;context, 0, sizeof *p-&gt;context);
  p-&gt;context-&gt;eip = (uint)forkret;

  return p;
}
</code></pre>
<h2><a class="header" href="#userinit関数" id="userinit関数">userinit関数</a></h2>
<p>変数pに、allocproc関数を使用してプロセステーブルからエントリを割り当てる。
このプロセスは最初initcode.Sを実行するために使用されるが、後からexecシステムコールによりinit.cを実行するプロセスに変わる。
そのため、initプロセスを持つためのproc.cの変数initprocに代入しておく。<br />
プロセスのpgdirフィールドにカーネル空間のページディレクトリエントリを持ったページディレクトリを作成する。
作成は<a href="chapter_05//chapter_05/05_03_kvmalloc.html#setupkvm%E9%96%A2%E6%95%B0">setupkvm関数</a>でvm.cのkmap配列を基に行われる。
inituvm関数で、initcode.Sを配置するためのページを割り当て、ページディレクトリにPDEとPTEを作成する。
initcode.SのTEXTセクションは仮想アドレス0から始まるので、0番目のPDEから変換するように作る。</p>
<p>initプロセスのトラップフレームの設定を行う。<br />
スケジューラによりinitプロセスにコンテキストスイッチされたとき、initプロセスのcontextフィールドのeipの値により、forkret関数が実行される。
さらにforkret関数からiret命令によりtrapret関数が実行され、トラップフレームの内容にしたがってプログラムが実行される。
ここではその準備をする。</p>
<ul>
<li><strong>cs:</strong> <a href="chapter_05//chapter_05/05_06_seginit.html">ユーザコードセグメントディスクリプタ</a>のエントリ番号（3）と、DPL3を設定する。</li>
<li><strong>ds:</strong> 同様にユーザデータセグメントディスクリプタのエントリ番号（4）と、DPL3を設定する。</li>
<li><strong>es, ss:</strong> データセグメントディスクリプタを設定する。
特に使用しないので、とりあえずデータセグメントディスクリプタを設定しているんだと思う。</li>
<li><strong>eflags:</strong> 9bit（Interrupt Enable Flag）のみを1に設定する（0x00000200）。
つまりユーザ空間に戻った後は割り込みが有効化される。
eflagsレジスタの各bitの役割については<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」（リンク8）</a>のVol.1「3.4.3 EFLAGS Register」の図3-8 「EFLAGS Register」に記載されている。</li>
<li><strong>esp:</strong> ページサイズ（4096）を設定する。
initcode.Sには1ページ分の領域しか割り当てないので、その中で最も高いアドレスにスタックポインタを設定する。</li>
<li><strong>eip:</strong> initcode.Sは仮想アドレス0から開始するようにリンクされているため0を設定する。</li>
</ul>
<p>プロセスの名前に「initcode」を設定する。
<a href="chapter_05//chapter_05/05_21_userinit.html#safestrcpy%E9%96%A2%E6%95%B0">safestrcpy関数</a>で即値 &quot;initcode&quot; をコピーしている。<br />
cwdフィールドにルートディレクトリのinode構造体を設定する。
namei関数はinode構造体を取得する。<br />
プロセスを実行する準備が整ったので、状態を実行可能状態とする。<br />
ここで、コメントにもあるように、他のAPでは既にスケジューラが動いているため、initプロセスが必ずしもBSPで実行されるとは限らない。
MakefileのCPUSを8とかにしてGDBでscheduler関数の途中で止めてinitcodeプロセスが実行されるときのapicidを確認すると、APで実行されるパターンを観測できる。</p>
<p>proc.c</p>
<pre><code class="language-c">void
userinit(void)
{
  struct proc *p;
  extern char _binary_initcode_start[], _binary_initcode_size[];

  p = allocproc();
  
  initproc = p;
  if((p-&gt;pgdir = setupkvm()) == 0)
    panic(&quot;userinit: out of memory?&quot;);
  inituvm(p-&gt;pgdir, _binary_initcode_start, (int)_binary_initcode_size);
  p-&gt;sz = PGSIZE;
  memset(p-&gt;tf, 0, sizeof(*p-&gt;tf));
  p-&gt;tf-&gt;cs = (SEG_UCODE &lt;&lt; 3) | DPL_USER;
  p-&gt;tf-&gt;ds = (SEG_UDATA &lt;&lt; 3) | DPL_USER;
  p-&gt;tf-&gt;es = p-&gt;tf-&gt;ds;
  p-&gt;tf-&gt;ss = p-&gt;tf-&gt;ds;
  p-&gt;tf-&gt;eflags = FL_IF;
  p-&gt;tf-&gt;esp = PGSIZE;
  p-&gt;tf-&gt;eip = 0;  // beginning of initcode.S

  safestrcpy(p-&gt;name, &quot;initcode&quot;, sizeof(p-&gt;name));
  p-&gt;cwd = namei(&quot;/&quot;);

  // this assignment to p-&gt;state lets other cores
  // run this process. the acquire forces the above
  // writes to be visible, and the lock is also needed
  // because the assignment might not be atomic.
  acquire(&amp;ptable.lock);

  p-&gt;state = RUNNABLE;

  release(&amp;ptable.lock);
}
</code></pre>
<h2><a class="header" href="#inituvm関数" id="inituvm関数">inituvm関数</a></h2>
<p>この関数はinitcode.Sをinitプロセスの0番目のPDEに配置するためだけに存在している。</p>
<p>pgdirにinitプロセスのページディレクトリのアドレスを受け、initにinitcode.Sの開始アドレス、szにinitcode.Sのサイズを受ける。<br />
まずszがページサイズ以上だった場合にpanicする。
理由は定かではないけど、恐らく、ページングが有効になっている都合上、initcode.Sが複数ページにわたるとkallocでも複数ページ確保しなければならず、initcode.Sを適切に分割して各ページに配置することが手間になるからだと思う。<br />
pgdirに仮想アドレス0から1ページ分の領域を、memの物理アドレスを参照するようにPDEとPTEを作成する。
作成には<a href="chapter_05//chapter_05/05_03_kvmalloc.html#mappages%E9%96%A2%E6%95%B0">mappages関数</a>を使用し、PTEの属性は書き込みフラグとユーザフラグを立てる。<br />
最後にinitcode.Sをmemmove関数でmemにコピーする。
memは<a href="chapter_05//chapter_05/05_03_kvmalloc.html#kalloc%E9%96%A2%E6%95%B0">kalloc関数</a>で割り当てる1ページ分の領域しか持っていないため、initプロセスは4kBに収まる必要がある。</p>
<p>vm.c</p>
<pre><code class="language-c">void
inituvm(pde_t *pgdir, char *init, uint sz)
{
  char *mem;

  if(sz &gt;= PGSIZE)
    panic(&quot;inituvm: more than a page&quot;);
  mem = kalloc();
  memset(mem, 0, PGSIZE);
  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
  memmove(mem, init, sz);
}
</code></pre>
<h2><a class="header" href="#safestrcpy関数" id="safestrcpy関数">safestrcpy関数</a></h2>
<p>この関数はsにtからn-1バイト分だけコピーする。
コピー先sはヌル終端される。</p>
<p>string.c</p>
<pre><code class="language-c">char*
safestrcpy(char *s, const char *t, int n)
{
  char *os;

  os = s;
  if(n &lt;= 0)
    return os;
  while(--n &gt; 0 &amp;&amp; (*s++ = *t++) != 0)
    ;
  *s = 0;
  return os;
}
</code></pre>
<h2><a class="header" href="#namei関数" id="namei関数">namei関数</a></h2>
<p>この関数はpathとして受け取ったパスのinode構造体を呼び出し元に返す。
中身としてはnamex関数を呼び出してその戻り値を返すだけ。
namex関数を呼び出す際にはnameiparentフラグ（第二引数）を0にしている。</p>
<p>fs.c</p>
<pre><code class="language-c">struct inode*
namei(char *path)
{
  char name[DIRSIZ];
  return namex(path, 0, name);
}
</code></pre>
<p>namex関数は引数pathで指定されたファイルのinode構造体を返す。
また、引数nameにファイル名を代入してくれる。<br />
引数nameiparentが0以外の場合は、pathの親ファイルのinode構造体を返す。</p>
<p>変数ipに、ルートディレクトリのinode構造体か、現在のプロセスのカレントディレクトリのinode構造体を代入する。
<a href="chapter_05//chapter_05/05_11_inode.html#inode%E6%A7%8B%E9%80%A0%E4%BD%93%E3%81%AE%E4%BD%9C%E6%88%90iget%E9%96%A2%E6%95%B0">iget</a>と<a href="chapter_05//chapter_05/05_11_inode.html#%E5%8F%82%E7%85%A7%E3%82%AB%E3%82%A6%E3%83%B3%E3%82%BF%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%AF%E3%83%AA%E3%83%A1%E3%83%B3%E3%83%88idup%E9%96%A2%E6%95%B0">idup</a>はiノードのところで見た。</p>
<p>whileループでpathのiノードを順に辿り、目的のiノードを探す。
条件式でskipelem関数を実行し、pathのファイル名をひとつずつ消化して、nameにその時のファイル名を代入し、pathを残りのパスで更新する。
つまり、namex関数の引数pathが単一のファイル名だった場合、whileループは行われない。</p>
<p>ループ内の処理を見る。<br />
ipがディレクトリ以外の場合、呼び出し元に0を返す。
このループに入る時点でipがディレクトリであることが確定しているため、この分岐は実質的なエラー処理にあたる。<br />
引数nameiparentが真かつpathの最後のループの場合、呼び出し元にnameのディレクトリを返す。
ここではip更新前なのでipはnameのひとつ上のディレクトリのinode構造体になっている。<br />
ipを更新するため、変数nextにipのディレクトリエントリでファイル名がnameと等しいエントリのinode構造体を取得する。
取得にはdirlookup関数を使用する。
この関数は第一引数のinode構造体のデータをバッファキャッシュから取得し、ディレクトリエントリから第二引数のnameとファイル名が等しいエントリのinodeを返してくれる。
第三引数は目的のディレクトリエントリが何番目だったかを返してくれるが、使用しないのでここでは0。</p>
<p>whileループが終わったとき、nameには引数pathの最後のファイル名が入っており、そのinode構造体がipに入っている。
引数nameiparentが真のときにwhileループ終了後まで来る場合は不正なので、<a href="chapter_05//chapter_05/05_11_inode.html#%E5%8F%82%E7%85%A7%E3%82%AB%E3%82%A6%E3%83%B3%E3%82%BF%E3%81%AE%E3%83%87%E3%82%AF%E3%83%AA%E3%83%A1%E3%83%B3%E3%83%88iput%E9%96%A2%E6%95%B0">iput関数</a>でipの参照カウンタをデクリメントし、必要であれば解放する。
pathが単一のファイル名だけだった場合がこれにあたる。</p>
<p>fs.c</p>
<pre><code class="language-c">static struct inode*
namex(char *path, int nameiparent, char *name)
{
  struct inode *ip, *next;

  if(*path == '/')
    ip = iget(ROOTDEV, ROOTINO);
  else
    ip = idup(myproc()-&gt;cwd);

  while((path = skipelem(path, name)) != 0){
    ilock(ip);
    if(ip-&gt;type != T_DIR){
      iunlockput(ip);
      return 0;
    }
    if(nameiparent &amp;&amp; *path == '\0'){
      // Stop one level early.
      iunlock(ip);
      return ip;
    }
    if((next = dirlookup(ip, name, 0)) == 0){
      iunlockput(ip);
      return 0;
    }
    iunlockput(ip);
    ip = next;
  }
  if(nameiparent){
    iput(ip);
    return 0;
  }
  return ip;
}
</code></pre>
<h2><a class="header" href="#skipelem関数" id="skipelem関数">skipelem関数</a></h2>
<p>この関数は引数pathの最初のファイル名を引数nameにコピーし、残りを戻り値として返す。<br />
コメントにExampleとして具体的な入出力が記載されている。<br />
ファイル名は最大14（DIRSIZ）バイト。</p>
<p>fs.c</p>
<pre><code class="language-c">// Examples:
//   skipelem(&quot;a/bb/c&quot;, name) = &quot;bb/c&quot;, setting name = &quot;a&quot;
//   skipelem(&quot;///a//bb&quot;, name) = &quot;bb&quot;, setting name = &quot;a&quot;
//   skipelem(&quot;a&quot;, name) = &quot;&quot;, setting name = &quot;a&quot;
//   skipelem(&quot;&quot;, name) = skipelem(&quot;////&quot;, name) = 0
//
static char*
skipelem(char *path, char *name)
{
  char *s;
  int len;

  while(*path == '/')
    path++;
  if(*path == 0)
    return 0;
  s = path;
  while(*path != '/' &amp;&amp; *path != 0)
    path++;
  len = path - s;
  if(len &gt;= DIRSIZ)
    memmove(name, s, DIRSIZ);
  else {
    memmove(name, s, len);
    name[len] = 0;
  }
  while(*path == '/')
    path++;
  return path;
}
</code></pre>
<h2><a class="header" href="#dirlookup関数" id="dirlookup関数">dirlookup関数</a></h2>
<p>この関数はディレクトリdpから引数nameと同名のディレクトリエントリを返す。
また、引数poffにディレクトリエントリが何番目だったかを返してくれる。</p>
<p>forループでディレクトリエントリを走査する。
dirent構造体の取得は<a href="chapter_05//chapter_05/05_11_inode.html#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E5%8F%96%E5%BE%97read%E9%96%A2%E6%95%B0">readi</a>で行う。</p>
<p>fs.h</p>
<pre><code class="language-c">#define DIRSIZ 14

struct dirent {
  ushort inum;
  char name[DIRSIZ];
};
</code></pre>
<p>fs.c</p>
<pre><code class="language-c">struct inode*
dirlookup(struct inode *dp, char *name, uint *poff)
{
  uint off, inum;
  struct dirent de;

  if(dp-&gt;type != T_DIR)
    panic(&quot;dirlookup not DIR&quot;);

  for(off = 0; off &lt; dp-&gt;size; off += sizeof(de)){
    if(readi(dp, (char*)&amp;de, off, sizeof(de)) != sizeof(de))
      panic(&quot;dirlookup read&quot;);
    if(de.inum == 0)
      continue;
    if(namecmp(name, de.name) == 0){
      // entry matches path element
      if(poff)
        *poff = off;
      inum = de.inum;
      return iget(dp-&gt;dev, inum);
    }
  }

  return 0;
}
</code></pre>
<p>namecmp関数はstrncmp関数で14文字比較する。<br />
strncmp関数はpとqを最大nバイト比較し、等しければ0、等しくなければ等しくなくなった文字の差を返す。</p>
<p>fs.c</p>
<pre><code class="language-c">int
namecmp(const char *s, const char *t)
{
  return strncmp(s, t, DIRSIZ);
}
</code></pre>
<p>string.c</p>
<pre><code class="language-c">int
strncmp(const char *p, const char *q, uint n)
{
  while(n &gt; 0 &amp;&amp; *p &amp;&amp; *p == *q)
    n--, p++, q++;
  if(n == 0)
    return 0;
  return (uchar)*p - (uchar)*q;
}
</code></pre>
<h1><a class="header" href="#522-スケジューラとコンテキストスイッチ" id="522-スケジューラとコンテキストスイッチ">5.22. スケジューラとコンテキストスイッチ</a></h1>
<p>scheduler関数は無限ループで次の2つを繰り返す。</p>
<ol>
<li>sti関数で割り込みを有効化する</li>
<li>プロセステーブルを走査して実行可能状態（RUNNABLE）のプロセスにコンテキストスイッチする</li>
</ol>
<p>最初にschedulerが実行されるとき、プロセステーブルの64個のプロセスの内、状態がRUNNABLEになっているのは<a href="chapter_05//chapter_05/05_21_userinit.html">userinit関数</a>で作成されたinitcode.Sのプロセスのみなので、それが実行されることになる。<br />
全てのプロセッサでschedulerが実行されており、プロセステーブルを触る可能性があるため、forループの前後でプロセステーブルのロックの取得と解放を行う。<br />
実行可能状態のプロセスを見つけた場合、switchuvm関数でコンテキストスイッチの準備を行う。<br />
準備ができたらプロセスを実行状態とし、swtch関数でコンテキストスイッチする。
コンテキストスイッチはTSSを用いたx86の機能を使うのではなく、スタックフレームの切り替えによって行う。<br />
その後再びプロセスからスケジューラにコンテキストスイッチされたとき、<a href="chapter_05//chapter_05/05_03_kvmalloc.html#switchkvm%E9%96%A2%E6%95%B0">switchkvm関数</a>でページディレクトリをカーネルのものに切り替え、cpu構造体のprocフィールドに0を代入する。</p>
<p>proc.c</p>
<pre><code class="language-c">void
scheduler(void)
{
  struct proc *p;
  struct cpu *c = mycpu();
  c-&gt;proc = 0;
  
  for(;;){
    // Enable interrupts on this processor.
    sti();

    // Loop over process table looking for process to run.
    acquire(&amp;ptable.lock);
    for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){
      if(p-&gt;state != RUNNABLE)
        continue;

      // Switch to chosen process.  It is the process's job
      // to release ptable.lock and then reacquire it
      // before jumping back to us.
      c-&gt;proc = p;
      switchuvm(p);
      p-&gt;state = RUNNING;

      swtch(&amp;(c-&gt;scheduler), p-&gt;context);
      switchkvm();

      // Process is done running for now.
      // It should have changed its p-&gt;state before coming back.
      c-&gt;proc = 0;
    }
    release(&amp;ptable.lock);

  }
}
</code></pre>
<h2><a class="header" href="#コンテキストスイッチ" id="コンテキストスイッチ">コンテキストスイッチ</a></h2>
<p>x86にはTSSディスクリプタを使用してコンテキストスイッチを行う機能があり、<a href="chapter_05//ref_books.html">「初めて読む486」（書籍2）</a>の8章「タスク」や、<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」（リンク8）</a>のVol.3 CHAPTER7「TASK MANAGEMENT」に記載があるが、xv6ではそれをフルに使わない。
TSSディスクリプタ自体はカーネルモードのスタックの情報とプロセスのIOMAPのために使用する。
これはLinuxカーネルも同様で、「詳解LINUXカーネル 第3版」（書籍3）の3.3.2「タスク状態セグメント」に記載がある。
xv6はタスク切り替えをスタックとret命令を使用して行う。</p>
<h2><a class="header" href="#switchuvm関数" id="switchuvm関数">switchuvm関数</a></h2>
<p>この関数はコンテキストスイッチするプロセスのTSS構造体とそのディスクリプタを作成し、ltr命令でそれをロードする。<br />
また、<a href="chapter_05//chapter_05/05_03_kvmalloc.html#switchkvm%E9%96%A2%E6%95%B0">lcr3関数</a>でプロセスのページディレクトリをcr3にロードする。</p>
<p>TSSディスクリプタはcpuの<a href="chapter_05//chapter_05/05_06_seginit.html">GDT</a>の5番目にセットする。
x86のコンテキストスイッチ機能を使用する場合はプロセス切り替え時に、切り替え前のプロセスと切り替え後のプロセスの2つのTSSディスクリプタがGDTに必要だが、その機能を使用しないので毎回GDTの5番目にTSSディスクリプタを格納する。
TSSとTSSディスクリプタの構造はIntel-SDM（リンク8）のVol.3 Figure 7-2「32-Bit Task-State Segment (TSS)」とVol.3 Figure 7-3「TSS Descriptor」に書いてある。
TSSディスクリプタはmmu.hに定義されているSEG16マクロを使用して作成する。<br />
Intel-SDMのFigure 7-3によるとtypeフィールドの次のbit（segdesc構造体のsフィールド）は常に0。
segdesc構造体のコメントを見ると、このbitは0がシステム、1がアプリケーションを表すことがわかる。<br />
SEG16マクロの第二引数baseには、cpu構造体のtsフィールドのアドレスを渡す。
tsフィールドはtaskstate構造体で、Intel-SDMのFigure 7-2と同じ構造をしている。<br />
TSSではカーネルモードで使用するスタックセグメント（ss）とスタックポインタ（esp）、IOMAP（iomb）のみを使用する。
iombフィールドにはプロセスからin命令やout命令でアクセスを許可するポートを設定する。
bitが0のときにアクセスの許可を示し、ここでは0xFFFFで全てのbitを1に設定しているため、プロセスはどのポートへもアクセスできない。<br />
ltr命令でTSSディスクリプタをtrレジスタにロードする。
GDTは1エントリ8バイトなので、5を3bit左シフト（5*2^3）することでTSSディスクリプタを指定する。<br />
プロセスのページディレクトリをcr3にロードし、仮想アドレス空間を切り替える。<br />
これでswitchuvm関数は終わりだが、まだeipやespの値は切り替わっていないため、scheduler関数に処理が戻る。</p>
<p>mmu.h</p>
<pre><code class="language-c">#define SEG_TSS   5  // this process's task state

/* 略 */

#define SEG16(type, base, lim, dpl) (struct segdesc)  \
{ (lim) &amp; 0xffff, (uint)(base) &amp; 0xffff,              \
  ((uint)(base) &gt;&gt; 16) &amp; 0xff, type, 1, dpl, 1,       \
  (uint)(lim) &gt;&gt; 16, 0, 0, 1, 0, (uint)(base) &gt;&gt; 24 }
</code></pre>
<p>vm.c</p>
<pre><code class="language-c">void
switchuvm(struct proc *p)
{
  if(p == 0)
    panic(&quot;switchuvm: no process&quot;);
  if(p-&gt;kstack == 0)
    panic(&quot;switchuvm: no kstack&quot;);
  if(p-&gt;pgdir == 0)
    panic(&quot;switchuvm: no pgdir&quot;);

  pushcli();
  mycpu()-&gt;gdt[SEG_TSS] = SEG16(STS_T32A, &amp;mycpu()-&gt;ts,
                                sizeof(mycpu()-&gt;ts)-1, 0);
  mycpu()-&gt;gdt[SEG_TSS].s = 0;
  mycpu()-&gt;ts.ss0 = SEG_KDATA &lt;&lt; 3;
  mycpu()-&gt;ts.esp0 = (uint)p-&gt;kstack + KSTACKSIZE;
  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
  // forbids I/O instructions (e.g., inb and outb) from user space
  mycpu()-&gt;ts.iomb = (ushort) 0xFFFF;
  ltr(SEG_TSS &lt;&lt; 3);
  lcr3(V2P(p-&gt;pgdir));  // switch to process's address space
  popcli();
}
</code></pre>
<h2><a class="header" href="#swtch関数" id="swtch関数">swtch関数</a></h2>
<p>この関数はスタックフレームの切り替えを行い、ret命令を使用してeipを切り替え先プロセスのリターンアドレスに移動させる。</p>
<p>この関数の動作を知るためにはGCCの関数呼び出し規約を知っている必要がある。
呼び出し規約は<a href="http://www.delorie.com/djgpp/doc/ug/asm/calling.html">「Guide: Function Calling Conventions」（リンク22）</a>でいくつかの具体例とともに解説されている。
関数呼び出し時にはスタックに引数が右から左に順にpushされ、次にリターンアドレスがpushされる。
つまり引数が2つある場合は、第二引数がスタックにpushされ、次に第一引数がpushされ、最後にリターンアドレスがpushされる。
また、関数に入るときと出るときとでebx、esi、edi、ebpの値が変更されてはいけない。</p>
<p>swtch関数の動きとしては、espを切り替え先プロセスのスタックに切り替え、そこに積まれているリターンアドレスにret命令でeipを移動する。<br />
初めてのschedulerが呼ばれてから、プロセスへの切り替えの流れは以下のようになる。</p>
<ol>
<li>swtch関数の第一引数にはスケジューラのコンテキスト（まだ0x0）、第二引数には<a href="chapter_05/chapter_05/05_21_userinit.html">userinit関数</a>で作成されたproc構造体のcontextフィールドが渡される。
この時点でスタックには次のように値が積まれている。
添え字は積まれている順番で、括弧内は入っている値。
popすると2番目（リターンアドレス）が取り出されることになる。<br />
  0: 第二引数（proc構造体のcontextフィールド）<br />
  1: 第一引数（スケジューラのコンテキスト0x0）<br />
  2: リターンアドレス（scheduler関数のswitchkvm関数を呼び出すアドレス）<br />
このとき、contextフィールドはcontext構造体だが、スタックと捉えることができる。
contextフィールドには次のように値が積まれている。<br />
  0: eip（forkret関数のアドレス）<br />
  1: ebp（0）<br />
  2: ebx（0）<br />
  3: esi（0）<br />
  4: edi（0）</li>
<li>スタックにebx、esi、edi、ebpの値を保存する。
スタックは次のようになる。<br />
  0: 第二引数（proc構造体のcontextフィールド）<br />
  1: 第一引数（スケジューラのコンテキスト0x0）<br />
  2: リターンアドレス（scheduler関数のswitchkvm関数を呼び出すアドレス）<br />
  3: ebp<br />
  4: ebx<br />
  5: esi<br />
  6: edi</li>
<li>スケジューラのcontext構造体がスタックを指すようにする（context構造体が完成する）。</li>
<li>espにproc構造体のcontextフィールドのアドレスを代入し、プロセスのスタックに切り替える。</li>
<li>プロセスのスタックからebx、esi、edi、ebpの値を復帰する。
スタックはeip（forkret関数のアドレス）のみが積まれた状態となる。</li>
<li>ret命令でforkret関数に移動し、プロセスの切り替えが終了する。</li>
</ol>
<p>proc.h</p>
<pre><code class="language-c">struct context {
  uint edi;
  uint esi;
  uint ebx;
  uint ebp;
  uint eip;
};
</code></pre>
<p>swtch.S</p>
<pre><code class="language-asm">.globl swtch
swtch:
  movl 4(%esp), %eax
  movl 8(%esp), %edx

  # Save old callee-saved registers
  pushl %ebp
  pushl %ebx
  pushl %esi
  pushl %edi

  # Switch stacks
  movl %esp, (%eax)
  movl %edx, %esp

  # Load new callee-saved registers
  popl %edi
  popl %esi
  popl %ebx
  popl %ebp
  ret
</code></pre>
<h1><a class="header" href="#6-fsimgの作成" id="6-fsimgの作成">6. fs.imgの作成</a></h1>
<p>initプロセスの実行を見る前にここで一度ファイルシステムの作成について見ることにする。
xv6で使用するファイルシステムはfs.imgとして作成される。</p>
<h1><a class="header" href="#7-initの実行" id="7-initの実行">7. initの実行</a></h1>
<h1><a class="header" href="#8-shの実行" id="8-shの実行">8. shの実行</a></h1>
<h1><a class="header" href="#参考リンク" id="参考リンク">参考リンク</a></h1>
<ol>
<li>「xv6 a simple, Unix-like teaching operating system」<br />
<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf">https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf</a></li>
<li>「xv6のデバッグ環境をつくる」<br />
<a href="https://qiita.com/ksky/items/974ad1249cfb2dcf5437">https://qiita.com/ksky/items/974ad1249cfb2dcf5437</a></li>
<li>「Using the GNU Compiler Collection (GCC)」<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc-6.5.0/gcc/">https://gcc.gnu.org/onlinedocs/gcc-6.5.0/gcc/</a></li>
<li>「Using ld The GNU linker ld version 2 January 1994」<br />
<a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html">https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html</a></li>
<li>「3 objcopy」<br />
<a href="https://sourceware.org/binutils/docs-2.35/binutils/objcopy.html#objcopy">https://sourceware.org/binutils/docs-2.35/binutils/objcopy.html#objcopy</a></li>
<li>「GNU make」<br />
<a href="https://www.gnu.org/software/make/manual/make.html">https://www.gnu.org/software/make/manual/make.html</a></li>
<li>「Keyboard scancodes Andries Brouwer」<br />
<a href="https://www.win.tue.nl/%7Eaeb/linux/kbd/scancodes.html">https://www.win.tue.nl/~aeb/linux/kbd/scancodes.html</a></li>
<li>「Intel 64 and IA-32 architectures software developer's manual combined volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4」<br />
<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html">https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html</a></li>
<li>「Bochs Developers Guide」. Kevin Lawton. Bryce Denney. Christophe Bothamy. Edited by Michael Calabrese<br />
<a href="http://bochs.sourceforge.net/doc/docbook/development/index.html">http://bochs.sourceforge.net/doc/docbook/development/index.html</a></li>
<li>「OSDev I/O Ports」<br />
<a href="https://wiki.osdev.org/I/O_Ports">https://wiki.osdev.org/I/O_Ports</a></li>
<li>「XT, AT and PS/2 I/O port addresses」<br />
<a href="http://bochs.sourceforge.net/techspec/PORTS.LST">http://bochs.sourceforge.net/techspec/PORTS.LST</a></li>
<li>「ProgrammerSought Gnu embedded assembly, inline assembly detailed introduction」<br />
<a href="https://programmersought.com/article/74671233226/">https://programmersought.com/article/74671233226/</a></li>
<li>「Wikipedia Control register」<br />
<a href="https://en.wikipedia.org/wiki/Control_register">https://en.wikipedia.org/wiki/Control_register</a></li>
<li>「MultiProcessor Specification Version 1.4」<br />
<a href="https://pdos.csail.mit.edu/6.828/2008/readings/ia32/MPspec.pdf">https://pdos.csail.mit.edu/6.828/2008/readings/ia32/MPspec.pdf</a></li>
<li>「OSDev Memory Map (x86)」<br />
<a href="https://wiki.osdev.org/Memory_Map_(x86)">https://wiki.osdev.org/Memory_Map_(x86)</a></li>
<li>「OSDev 8259 PIC」<br />
<a href="https://wiki.osdev.org/PIC">https://wiki.osdev.org/PIC</a></li>
<li>「OSDev IOAPIC」<br />
<a href="https://wiki.osdev.org/IOAPIC">https://wiki.osdev.org/IOAPIC</a></li>
<li>「82093AA I/O ADVANCED PROGRAMMABLE INTERRUPT CONTROLLER (IOAPIC)」<br />
<a href="http://web.archive.org/web/20161130153145/http://download.intel.com/design/chipsets/datashts/29056601.pdf">http://web.archive.org/web/20161130153145/http://download.intel.com/design/chipsets/datashts/29056601.pdf</a></li>
<li>「Hardware Level VGA and SVGA Video Programming Information Page CRT Controller Registers」<br />
<a href="http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/crtcreg.htm">http://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/crtcreg.htm</a></li>
<li>「OSDev Drawing In Protected Mode」<br />
<a href="https://wiki.osdev.org/Drawing_In_Protected_Mode">https://wiki.osdev.org/Drawing_In_Protected_Mode</a></li>
<li>「OSDev Text UI」<br />
<a href="https://wiki.osdev.org/Text_UI">https://wiki.osdev.org/Text_UI</a></li>
<li>「Guide: Function Calling Conventions」<br />
<a href="http://www.delorie.com/djgpp/doc/ug/asm/calling.html">http://www.delorie.com/djgpp/doc/ug/asm/calling.html</a></li>
<li>「OSDev ATA PIO Mode」<br />
<a href="https://wiki.osdev.org/ATA_PIO_Mode">https://wiki.osdev.org/ATA_PIO_Mode</a></li>
<li>「OSDev ATA Command Matrix」<br />
<a href="https://wiki.osdev.org/ATA_Command_Matrix">https://wiki.osdev.org/ATA_Command_Matrix</a></li>
<li>「OSDev LBA」<br />
<a href="https://wiki.osdev.org/LBA">https://wiki.osdev.org/LBA</a></li>
<li>「AsTechLog WSL2＋Ubuntu 20.04でGUIアプリを動かす」<br />
<a href="https://astherier.com/blog/2020/08/run-gui-apps-on-wsl2/#toc_id_2">https://astherier.com/blog/2020/08/run-gui-apps-on-wsl2/#toc_id_2</a></li>
<li>「ASCII Code - The extended ASCII table」<br />
<a href="https://www.ascii-code.com/">https://www.ascii-code.com/</a></li>
<li>「Serial Programming/8250 UART Programming」<br />
<a href="https://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming">https://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming</a></li>
<li>「OSDev Interrupt」<br />
<a href="https://wiki.osdev.org/Interrupts">https://wiki.osdev.org/Interrupts</a></li>
</ol>
<h1><a class="header" href="#参考書籍" id="参考書籍">参考書籍</a></h1>
<ol>
<li>坂井 弘亮. リンカ・ローダ 実践開発テクニック. CQ出版社. 978-4-7898-3807-8</li>
<li>蒲地 輝尚. 初めて読む486. アスキー出版局. 4-7561-0213-1</li>
<li>DANIEL P. BOVET, MARCO CASTATI. 詳解LINUXカーネル 第3版. オライリー・ジャパン. 978-4-87311-313-5</li>
<li>Hisa Ando. プロセッサを支える技術. 技術評論社. 978-4-7741-4521-1</li>
<li>David A.Patterson, John L.Hennessy. コンピュータの構成と設計 第4版. 日経BP社. 978-4-8222-8479-4</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
